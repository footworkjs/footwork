// component.js
// ------------------

var originalComponentRegisterFunc = ko.components.register;
var registerComponent = ko.components.register = function(componentName, options) {
  var viewModel = options.initialize || options.viewModel;
  
  if( !isString(componentName) ) {
    throw 'Components must be provided a componentName.';
  }

  //TODO: determine how mixins from the (optionally) supplied footwork viewModel mix in with the mixins supplied directly in the component options
  //      as well as others like params, afterBinding. Currently we will just use the viewModel's mixins/etc, only the namespace is overridden
  //      from the component definition/configuration.
  if( isViewModelCtor(viewModel) ) {
    viewModel.__configParams['componentNamespace'] = componentName;
  } else if( isFunction(viewModel) ) {
    options.namespace = componentName;
    viewModel = makeViewModel(options);
  }

  originalComponentRegisterFunc(componentName, {
    viewModel: viewModel,
    template: options.template
  });
};

var makeComponent = ko.component = function(componentDefinition) {
  var viewModel = componentDefinition.viewModel;

  if( isFunction(viewModel) && !isViewModelCtor(viewModel) ) {
    componentDefinition.viewModel = makeViewModel( omit(componentDefinition, 'template') );
  }

  return componentDefinition;
};

// These are tags which are ignored by the custom component loader
// Sourced from: https://developer.mozilla.org/en-US/docs/Web/HTML/Element
var normalTags = [
  'a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bgsound',
  'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',
  'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element',
  'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frameset', 'g', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
  'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label',
  'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'nobr',
  'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'polygon', 'path', 'pre',
  'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'small', 'source', 'spacer',
  'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea',
  'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', 'xmp'
];
var tagIsComponent = ko.components.tagIsComponent = function(tagName, isComponent) {
  isComponent = ( isUndefined(isComponent) ? true : isComponent );

  if( isArray(tagName) ) {
    each(tagName, function(tag) {
      tagIsComponent(tag, isComponent);
    });
  }

  if(isComponent !== true) {
    if( contains(normalTags, tagName) === false ) {
      normalTags.push(tagName);
    }
  } else {
    normalTags = filter(normalTags, function(normalTagName) {
      return normalTagName !== tagName;
    });
  }
};

function componentTriggerAfterBinding(element, viewModel) {
  if( isViewModel(viewModel) ) {
    var configParams = viewModel.__getConfigParams();
    if( isFunction(configParams.afterBinding) ) {
      configParams.afterBinding.call(viewModel, element);
    }
  }
}

// Use the $compLifeCycle wrapper binding to provide lifecycle events for components
ko.virtualElements.allowedBindings.$compLifeCycle = true;
ko.bindingHandlers.$compLifeCycle = {
  init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      if( isViewModel(viewModel) ) {
        viewModel.__shutdown();
      }
    });
  },
  update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    if( isViewModel(viewModel) ) {
      componentTriggerAfterBinding(element, viewModel);
    }

    var child = ko.virtualElements.firstChild(element);
    if( !isUndefined(child) ) {
      viewModel = ko.dataFor( child );
      componentTriggerAfterBinding(element, viewModel);
    }
  }
};

// Components which footwork will not wrap in the $compLifeCycle custom binding used for lifecycle events
// Used to keep the wrapper off of internal/natively handled and defined components such as 'outlet'
var nativeComponents = [
  'outlet'
];

// Custom loader used to wrap components with the $compLifeCycle custom binding
var componentWrapperTemplate = '<!-- ko $compLifeCycle -->COMPONENT_MARKUP<!-- /ko -->';
ko.components.loaders.unshift( ko.components.componentWrapper = {
  loadTemplate: function(componentName, config, callback) {
    if( nativeComponents.indexOf(componentName) === -1 ) {
      // TODO: Handle different types of configs
      if( isString(config) ) {
        config = componentWrapperTemplate.replace(/COMPONENT_MARKUP/, config);
      } else {
        throw 'Unhandled config type ' + typeof config + '.';
      }
      ko.components.defaultLoader.loadTemplate(componentName, config, callback);
    } else {
      callback(null);
    }
  },
  loadViewModel: function(componentName, config, callback) {
    var ViewModel = config.viewModel || config;
    if( nativeComponents.indexOf(componentName) === -1 ) {
      callback(function(params, componentInfo) {
        var $context = ko.contextFor(componentInfo.element);
        if( isViewModelCtor(ViewModel) ) {
          // inject the context into the ViewModel contructor
          ViewModel = ViewModel.compose({
            _preInit: function() {
              this.$context = $context;
            }
          });
        }
        return new ViewModel(params);
      });
    } else {
      callback(null);
    }
  }
});

// The footwork getConfig loader is a catch-all in the instance a registered component cannot be found.
// The loader will attempt to use requirejs via knockouts integrated support if it is available.
ko.components.loaders.push( ko.components.requireLoader = {
  getConfig: function(componentName, callback) {
    var combinedFile = componentName + resourceFileExtensions.combined;
    var viewModelFile = componentName + resourceFileExtensions.viewModel;
    var templateFile = componentName + resourceFileExtensions.template;
    var componentLocation = getResourceLocation(componentName);
    var configOptions = null;
    var viewModelPath;
    var templatePath;
    var combinedPath;

    if( isFunction(require) ) {
      // load component using knockouts native support for requirejs
      if( require.defined(componentName) ) {
        // component already cached, lets use it
        configOptions = {
          require: componentName
        };
      } else if( isString(componentLocation.combined) ) {
        combinedPath = componentLocation.combined;

        if( isPath(combinedPath) ) {
          combinedPath = combinedPath + combinedFile;
        }

        configOptions = {
          require: combinedPath
        };
      } else {
        viewModelPath = componentLocation.viewModels;
        templatePath = 'text!' + componentLocation.templates;

        if( isPath(viewModelPath) ) {
          viewModelPath = viewModelPath + viewModelFile;
        }
        if( isPath(templatePath) ) {
          templatePath = templatePath + templateFile;
        }
        
        configOptions = {
          viewModel: { require: viewModelPath },
          template: { require: templatePath }
        };
      }
    }

    callback(configOptions);
  }
});

var noParentViewModelError = { getNamespaceName: function() { return 'NO-VIEWMODEL-IN-CONTEXT'; } };
ko.virtualElements.allowedBindings.$outletBind = true;
ko.bindingHandlers.$outletBind = {
  init: function(element, valueAccessor, allBindings, outletViewModel, bindingContext) {
    var $parentViewModel = ( isObject(bindingContext) ? (bindingContext.$parent || noParentViewModelError) : noParentViewModelError);
    var $parentRouter = nearestParentRouter(bindingContext);
    var outletName = outletViewModel.outletName;

    if( isRouter($parentRouter) ) {
      // register this outlet with the router so that updates will propagate correctly
      // take the observable returned and define it on the outletViewModel so that outlet route changes are reflected in the view
      outletViewModel.$outletRoute = $parentRouter.$outlet( outletName );
    } else {
      throw 'Outlet [' + outletName + '] defined inside of viewModel [' + $parentViewModel.getNamespaceName() + '] but no router was defined.';
    }
  }
};

ko.components.register('outlet', {
  autoIncrement: true,
  viewModel: function(params) {
    this.outletName = ko.unwrap(params.name);
    this.__isOutlet = true;
  },
  template: '<!-- ko $outletBind, component: $outletRoute --><!-- /ko -->'
});

ko.components.register('_noComponentSelected', {
  viewModel: function(params) {
    this.__assertPresence = false;
  },
  template: '<div class="no-component-selected"></div>'
});

ko.components.register('error', {
  viewModel: function(params) {
    this.message = ko.observable(params.message);
    this.errors = params.errors;
    this.__assertPresence = false;
  },
  template: '\
    <div class="component error" data-bind="foreach: errors">\
      <div class="error">\
        <span class="number" data-bind="text: $index() + 1"></span>\
        <span class="message" data-bind="text: $data"></span>\
      </div>\
    </div>'
});