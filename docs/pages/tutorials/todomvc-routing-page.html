<article>

  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction - Routing</h1>
    </header>
    <div class="content">
      <div class="note"><span class="label">NOTE:</span> It is assumed you have gone through the previous
        <a href="/tutorials/TodoMVC/creatingApplication" data-bind="$route">Creating the Application</a> tutorial. The code in here is based off of where that tutorial
          left off, so if you haven't checked it out yet you should!</div>

      <p>What SPA is complete without routing? In this tutorial we will be adding a login page to the application as well as the necessary code to route between
        <span class="inline-code">'/'</span> and <span class="inline-code">'/todo</span>.</p>
      
      <p>Routing in a single page app is about managing the state of application. This can include the loading of different views, or triggering some other change
        based on the URL in the address bar. The router in footwork has many features, including the ability to nest routers as well as many differing
        route configurations. The example shown in this tutorial is relatively basic, for a full explanation on footworks routing capabilities take a look at the
        <a href="/api/routing" data-bind="$route">routing API documentation</a>.</p>

      <p>There are 3 principle components of routers in footwork which make useful:</p>

      <ul>
        <li><a data-bind="$route" href="/api/routing#configuration" data-bind="$route">configuration object</a>: A router configuration on a viewModel. Used to define
          the router, its routes, controllers, and their actions.</li>
        <li><a data-bind="$route" href="/api/routing#outlets" data-bind="$route">outlets</a>: Any number of
          <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declarations in your HTML which are the output points your router controls.</li>
        <li><a data-bind="$route" href="/api/routing#route-binding" data-bind="$route">route bindings</a>: Special bindings for links (and other tags) which will
          initiate new states in your application.</li>
      </ul>

      <p>The first thing we need to do when setting up a router in footwork, is deciding where it will 'live'. Routers in footwork are attached to viewModels,
        specified either in a standalone <span class="inline-code">&lt;viewModel&gt;</span> or on a <span class="inline-code">viewModel</span> which is part of a component.
        The reason for this is that the <span class="inline-code">outlet</span> and <span class="inline-code">$route</span> binding declarations are controlled by 
        (or attach themselves to) the nearest parent <span class="inline-code">router</span> found in the DOM. So a <span class="inline-code">router</span> needs to be bound to the DOM along with a
        <span class="inline-code">viewModel</span> so that it can be found.</p>

      <p>This parent-seeking nature allows for outlets and <span class="inline-code">$route</span> bindings which can be nested as deeply as you would like within
        other elements, viewModels, components, etc.</p>
    </div>
  </section>

  <a id="viewModel-router" class="section-anchor"></a>
  <section name="viewModel-router">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">viewModel and router</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/viewModelRouter" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/amd...viewModelRouter" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f viewModelRouter</code></pre>
        </div>
      </div>

      <p>For our todo application, we will only need one router which will control one <span class="inline-code">outlet</span>. Since this router is to control the
        entirety of the application it makes sense to put it on an 'outermost' viewModel so that anything we might want to control will be a decendant (or inside
        the scope of) the DOM for that router.</p>

      <p>Looking at our current code, we don't actually have a viewModel that encompasses the entire application, we currently have the
        <span class="inline-code">TodoForm</span> and the <span class="inline-code">TodoList</span> (as well as <span class="inline-code">TodoItem</span>) viewModels.
        All of these elements belong on a single 'page'...the todo list page. So lets start by creating a container <span class="inline-code">viewModel</span> that will wrap our
        aforementioned viewModels and components. We will place our router configuration on that 'wrapper' <span class="inline-code">viewModel</span>.</p>

      <h3>First, lets wrap our HTML with a new <span class="inline-code">&lt;viewModel&gt;</span> declaration:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;body&gt;
    &lt;viewModel module="Main"&gt; &lt;!-- new 'Main' viewModel wrapper which will have our router --&gt;
      &lt;main&gt;
        &lt;todoform&gt;&lt;/todoform&gt;
        &lt;viewModel module="TodoList"&gt;
          &lt;!-- ... --&gt;
        &lt;/viewModel&gt;
      &lt;/main&gt;
    &lt;/viewModel&gt;
    &lt;script src="bower_components/requirejs/require.js" data-main="scripts/app"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;!-- ... --&gt;</code></pre>

      <p>Now we need to prepare the <span class="inline-code">viewModel</span> which will house our router for us. A router is created when a viewModel that has a router
        configuration is instantiated. Lets create our new <span class="inline-code">Main</span> viewModel with a basic router configuration so that
        when footwork processes the <span class="inline-code">&lt;viewModel&gt;</span> declaration our viewModel will be instantiated along with it.</p>

      <h3>Our <span class="inline-code">Main</span> viewModel with its basic router configuration object:</h3>
<div class="file-location">/scripts/viewModels/Main.js</div>
<pre><code class="javascript">define(['footwork'],
  function(fw) {
    return fw.viewModel({
      namespace: 'Main',
      router: {
        routes: [
          {
            route: '/',
            title: 'Todo Application Tutorial',
            controller: function() {
              // show our login page here
            }
          },
          {
            route: '/todo',
            title: 'Todo List',
            controller: function() {
              // show our todo list page here
            }
          }
        ]
      }
    });    
  }
);</code></pre>

      <div class="note"><span class="label">NOTE:</span> There are many available options for routers, the preceding definition keeps it simple for sake of the
        tutorial. If you want the in-depth overview of options available (and other things) for routers then take a look at the 
        <a href="/api/routing" data-bind="$route">router API documentation</a>.</div>

      <p>What we see above is a very basic <span class="inline-code">viewModel</span> definition which has a router configuration (we will fill it out a bit more later on).
        The router configuration defines two routes <span class="inline-code">'/'</span> (which we will use to display our login page) and <span class="inline-code">'/todo'</span> (which we will use to display
        the todo list).</p>

      <p>Now, we call <span class="inline-code">fw.viewModels.registerLocation()</span>
        just as we did in the preceeding (<a href="#amd-requirejs" data-bind="$route">amd</a>) step so that footwork knows where to find it when it encounters the <span class="inline-code">&lt;viewModel&gt;</span>
        declaration in our markup.</p>

      <h3>Register the location of our new <span class="inline-code">Main</span> viewModel:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// ...
  /**
   * Tell footwork it can find both the 'Main' and 'TodoList' viewModels
   * inside of /scripts/viewModels.
   */
  fw.viewModels.registerLocation([
    'Main',
    'TodoList'
  ], '/scripts/viewModels/');
// ...</code></pre>
    </div>
  </section>

  <a id="outlet" class="section-anchor"></a>
  <section name="outlet">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Creating an outlet</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/createOutlet" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/viewModelRouter...createOutlet" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f createOutlet</code></pre>
        </div>
      </div>

      <p>Now lets create the <span class="inline-code">&lt;outlet&gt;</span> declaration which our router will use to display different views/pages on.</p>

      <p>We do this by pulling out the section of HTML we would like to turn into a page, and replacing it with an <span class="inline-code">&lt;outlet&gt;</span>. For our todo tutorial, we plan on having
        two 'views' or pages...one for the login screen, and one to display the todo list once logged in. While we pull out the HTML for our todo list page, lets add in a header which we will use to display
        the login status for our application.</p>

      <h3>Replace the content of our app with the <span class="inline-code">&lt;outlet&gt;</span> and create the header:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;body&gt;
    &lt;viewModel module="Main"&gt; &lt;!-- new 'Main' viewModel which has our router --&gt;
      &lt;header&gt;
        &lt;div class="title"&gt;Things To Do...&lt;/div&gt;
      &lt;/header&gt;
      &lt;main&gt;
        &lt;outlet name="mainView"&gt;&lt;/outlet&gt; &lt;!-- HTML replaced with outlet --&gt;
      &lt;/main&gt;
    &lt;/viewModel&gt;
    &lt;script src="bower_components/requirejs/require.js" data-main="scripts/app"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;!-- ... --&gt;</code></pre>
    </div>
  </section>

  <a id="outlet-views" class="section-anchor"></a>
  <section name="outlet-views">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Creating Views</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/creatingViews" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/createOutlet...creatingViews" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f creatingViews</code></pre>
        </div>
      </div>

      <p>Now that our <span class="inline-code">&lt;outlet&gt;</span> is where our HTML once was, we need to put that HTML somewhere and load it as a view in the outlet. We do that by creating new
        files which will store the markup and telling footwork where it can find it.</p>

      <h3>First we take the HTML we removed from the <span class="inline-code">index.html</span> and place it in a view file:</h3>
<div class="file-location">/scripts/views/todo-page.html</div>
<pre><code class="html">&lt;todoform&gt;&lt;/todoform&gt;
&lt;viewModel module="TodoList"&gt;
  &lt;div class="todo-list"&gt;
    &lt;div class="todos" data-bind="foreach: todos"&gt;
      &lt;div class="todo"&gt;
        &lt;div class="status icon-check"&gt;&lt;/div&gt;
        &lt;div class="text" data-bind="text: thingToDo"&gt;&lt;/div&gt;
        &lt;div class="clear icon-x"&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/viewModel&gt;</code></pre>

      <p class="note"><span class="label">NOTE:</span> If you notice, the HTML we removed from the <span class="inline-code">index.html</span> is unchanged, we simply dropped it in the new
        <span class="inline-code">todo-page.html</span> file.</p>

      <p>Now we should create the other view we will have, the login page...for this we will also need a login form. Lets go ahead and create the <span class="inline-code">Login</span> viewModel
        and bindings in the markup just like we had done for the <span class="inline-code">TodoForm</span> form we made earlier.</p>

      <h3>Create the HTML (along with bindings) for the <span class="inline-code">login-page.html</span>:</h3>
<div class="file-location">/scripts/views/login-page.html</div>
<pre><code class="html">&lt;viewModel module="LoginForm"&gt;
  &lt;form class="login" data-bind="submit: loginUser"&gt;
    &lt;div class="title"&gt;Please Login...&lt;/div&gt;
    &lt;label&gt;
      &lt;span&gt;Username:&lt;/span&gt;
      &lt;input type="text" data-bind="value: username" autofocus&gt;
    &lt;/label&gt;
    &lt;label&gt;
      &lt;span&gt;Password:&lt;/span&gt;
      &lt;input type="password" data-bind="value: password"&gt;
    &lt;/label&gt;
    &lt;button&gt;Login&lt;/button&gt;
  &lt;/form&gt;
&lt;/viewModel&gt;</code></pre>

      <h3>Create the <span class="inline-code">LoginForm</span> viewModel that goes along with the form:</h3>
<div class="file-location">/scripts/viewModels/LoginForm.js</div>
<pre><code class="javascript">define(['footwork'],
  function(fw) {
    return fw.viewModel({
      namespace: 'LoginForm',
      initialize: function() {
        this.username = fw.observable();
        this.password = fw.observable();
        this.loginUser = function() {
          console.info('Login form submitted!');
        };
      }
    });
  }
);</code></pre>

      <h3>Remember, since we have a new <span class="inline-code">viewModel</span> we must also tell footwork where it can find it:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// ...
  /**
   * Tell footwork it can find the 'Main', 'LoginForm', and 'TodoList' viewModels
   * inside of /scripts/viewModels.
   */
  fw.viewModels.registerLocation([
    'Main',
    'LoginForm',
    'TodoList'
  ], '/scripts/viewModels/');
// ...</code></pre>
    </div>
  </section>

  <a id="changing-outlet" class="section-anchor"></a>
  <section name="changing-outlet">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Changing the outlet</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/changingOutlet" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/creatingViews...changingOutlet" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f changingOutlet</code></pre>
        </div>
      </div>

      <p>Ok, now we have everything we need to start rendering different pages. We just need to add a couple things to our <span class="inline-code">router</span> configuration. Remember
        those two routes we defined in the <span class="inline-code">Main</span> <span class="inline-code">viewModel</span> definition? We need to make the controllers on those routes show their respective
        pages in our <span class="inline-code">&lt;outlet&gt;</span>.</p>

      <p>Changing what is displayed in an <span class="inline-code">&lt;outlet&gt;</span> is accomplished via <span class="inline-code">router.$outlet()</span> calls.
        <span class="inline-code">router.$outlet()</span> is simply a method on the router which is used to control whatever outlets are attached to it.</p>

      <div class="note"><span class="label">NOTE:</span> Remember, outlets will find their nearest parent <span class="inline-code">router</span> in the DOM...so you just need to ensure that your
        <span class="inline-code">&lt;outlet&gt;</span> is a child element of the <span class="inline-code">viewModel</span> a router is defined on. You can read about
        outlets in detail on the <a href="/api/routing#outlets" data-bind="$route">router API documentation</a>.</div>

      <h3>Update our routes to display their respective pages inside of the <span class="inline-code">outlet</span>:</h3>
<div class="file-location">/scripts/viewModels/Main.js</div>
<pre><code class="javascript">// ...
  routes: [
    {
      route: '/',
      title: 'Todo Application Tutorial',
      controller: function() {
        // show our login page here
        this.$outlet('mainView', 'login-page');
      }
    },
    {
      route: '/todo',
      title: 'Todo List',
      controller: function() {
        // show our todo list page here
        this.$outlet('mainView', 'todo-page');
      }
    }
  ]
// ...</code></pre>

      <p>So thats it, right? Well lets reload the page and see where we are at:</p>

      <div class="figure">
        <div class="title">Footwork tried to find our view for us, but failed...</div>
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/routing0.png"></div>
        </div>
      </div>

      <p>What the heck happened here? Well, footwork tried as best it could to find and download the view for us...but it guessed wrong. Footwork has a 'default path' it will attempt to download from
        when all else fails, the error we see here is the result of that download attempt (the default location is configurable, see <span class="inline-code">fw.components.defaultLocation()</span> in the
        <a href="/api/components#loading-registering" data-bind="$route">API docs</a>).</p>

      <div class="note">
        <p><span class="label">NOTE:</span> You may also have noticed it tried to download a <span class="inline-code">viewModel</span> as well as a template...why is that?</p>
        <p>When you tell an <span class="inline-code">outlet</span> to show something, you are actually telling it to render a <span class="inline-code">component</span>. Because most 'views' you might want to show in an
          <span class="inline-code">outlet</span> consist of a template/HTML and no <span class="inline-code">viewModel</span>, footwork provides a couple helper methods that make it easy
          to create a <span class="inline-code">component</span> that has no corresponding <span class="inline-code">viewModel</span>. These methods are outlined in detail in the
          <a href="/api/routing#outlet-registering" data-bind="$route">outlet API documentation</a>.</p>
      </div>

      <p>Ok so everything is done except for <em>one final</em> thing. We need to tell footwork where it can find our page views. We can do this with
        <span class="inline-code">fw.outlets.registerView()</span>.</p>

      <h3>Register our two views using <span class="inline-code">fw.outlets.registerView()</span>:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// ...
  /**
   * Tell footwork it can find the 'Main', 'Login', and 'TodoList' viewModels
   * inside of /scripts/viewModels.
   */
  fw.viewModels.registerLocation([
    'Main',
    'LoginForm',
    'TodoList'
  ], '/scripts/viewModels/');

  fw.outlets.registerViewLocation([
    'login-page',
    'todo-page'
  ], '/scripts/views/');
// ...</code></pre>

      <p>With our views both properly registered, lets reload the page once more:</p>

      <div class="figure">
        <div class="title">Success!</div>
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/routing1.png"></div>
        </div>
      </div>

      <h3>Now, click submit:</h3>
      <div class="figure no-title">
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/routing2.png"></div>
        </div>
      </div>

      <p>Great, so now we have a login page that is being routed to by our default <span class="inline-code">'/'</span> route. That routes controller is being triggered and we tell the <span class="inline-code">outlet</span>
        to render the <span class="inline-code">login-page</span> view. That view is dynamically loaded for us and rendered on the page with our <span class="inline-code">Login</span> <span class="inline-code">viewModel</span>
        then also being downloaded and instantiated for us too.</p>

      <p>Now we just need to get it to switch to the other view...but how do we tell the router to jump to the <span class="inline-code">'/todo'</span> route (and thus trigger the <span class="inline-code">outlet</span> change
        to the <span class="inline-code">todo-page</span>) once a user clicks login? You might have guessed it...send a message! Or more accurately, in this instance we will trigger an <span class="inline-code">event</span>.</p>

      <p>Remember, the <span class="inline-code">router</span> is instantiated on the <span class="inline-code">viewModel</span> it is configured with. Our <span class="inline-code">router</span> must then be attached
        to the <span class="inline-code">Main</span> <span class="inline-code">viewModel</span>. So lets tell it when the user submits the form.</p>
    </div>
  </section>

  <a id="manipulating-route" class="section-anchor"></a>
  <section name="manipulating-route">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Manipulating the Route</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/manipulatingRoute" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/changingOutlet...manipulatingRoute" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f manipulatingRoute</code></pre>
        </div>
      </div>

      <p>Footwork provides two basic avenues for altering the state of your application.</p>
      <ul>
        <li>Direct manipulation via <span class="inline-code">router.setState()</span></li>
        <li><span class="inline-code">$route</span> binding to a DOM element event (ex: a click on an <span class="inline-code">&lt;a href=""&gt;</span>).</li>
      </ul>

      <p>Directly manipulating the <span class="inline-code">router</span> state requires having a reference to it. Since our <span class="inline-code">router</span> is instantiated on the <span class="inline-code">Main</span>
        <span class="inline-code">viewModel</span> it has a reference to it on <span class="inline-code">viewModel.$router</span>. What we need to do is tell the <span class="inline-code">Main</span>
        <span class="inline-code">viewModel</span> when the new user logs in and what that username is so that it can alter the route for us. Lets trigger an <span class="inline-code">event</span> to do that.</p>

      <h3>First, we write the code to trigger the event from the <span class="inline-code">LoginForm</span>:</h3>
<div class="file-location">/scripts/viewModels/LoginForm.js</div>
<pre><code class="javascript">// ...
  namespace: 'LoginForm',
  initialize: function() {
    /**
     * Create a new namespace instance we will use to communicate with
     * the Main viewModel.
     */
    this.mainNamespace = fw.namespace('Main');

    this.username = fw.observable();
    this.password = fw.observable();
    this.loginUser = function() {
      // Tell the Main viewModel what user has logged in
      this.mainNamespace.trigger('userLogin');
    };
  }
// ...</code></pre>

      <div class="note"><span class="label">NOTE: </span> new <span class="inline-code">namespace</span> instances should be assigned to <span class="inline-code">this</span> (the <span class="inline-code">viewModel</span>).
        This ensures that footwork can clean up any subscriptions, handlers, etc if/when the <span class="inline-code">viewModel</span> is disposed of (such as when you navigate to a new route/page).</div>

      <p>Now we need to receive that event on the <span class="inline-code">Main</span> <span class="inline-code">viewModel</span> (our <span class="inline-code">viewModel</span> that has the
        <span class="inline-code">router</span>)...lets add that code.</p>

<div class="file-location">/scripts/viewModels/Main.js</div>
<pre><code class="javascript">// ...
  /**
   * Add the initialize method which is called when the Main viewModel is instantiated.
   * We then setup the event handler for 'userLogin' messages received on this.$namespace
   */
  initialize: function() {
    // Create reference to the viewModel we will use in the callback
    var self = this;

    // Create the event handler which receives the 'userLogin' event
    this.$namespace.event.handler('userLogin', function() {
      // Tell the router to route to '/todo'
      self.$router.setState('/todo');
    });
  }
// ...</code></pre>

      <p>Ok...refresh the page and click login (username/password optional at the moment). You should see the route change to <span class="inline-code">/#todo</span> (the hash is there because we are using HTML4 hash-based routing).
        You should also see the <span class="inline-code">todo-list.html</span> rendered in place of the login form. Yay! You now know the basics of routing in footwork.</p>

      <p>You might be thinking 'but I just want to put a link in there, why do I have to send these events around...seems like a lot of work'. And I would agree with you, but sometimes it is necessary when your route doesn't
        neatly correspond to a link on your page, this was an example showing how to do that. However if you do actually need a link/button to a URL you can use <span class="inline-code">$route</span> bindings.</p>

      <p><span class="inline-code">$route</span> bindings are simply a <span class="inline-code">data-bind</span> attribute you give to an element. That binding tells footwork you want to change the route based on
        an event on the element it is bound to. Basically we can turn <span class="inline-code">&lt;a href=""&gt;</a></span> tags (or any other tag) into something you can click on to trigger the new state/route.</p>

      <p>With our todo application we currently have no way to logout. Once you click <span class="inline-code">Login</span> you are in the application, yes you can go 'back'...but that isn't very user friendly. We need a logout
        button to send us back to <span class="inline-code">'/'</span>. Lets use a <span class="inline-code">$route</span> binding to do that.</p>

      <h3>Add a <span class="inline-code">$route</span> binding to a logout <span class="inline-code">&lt;a href=""&gt;</span> link/button:</h3>

<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;header&gt;
    &lt;div class="title"&gt;Things To Do...&lt;/div&gt;

    &lt;!-- new $route bound link --&gt;
    &lt;a href="/" data-bind="$route" class="logout button"&gt;Logout&lt;/a&gt;
  &lt;/header&gt;
&lt;!-- ... --&gt;</code></pre>

      <p>Thats it...reload the page and after clicking login we should see our new button. When setting up, a <span class="inline-code">$route</span> binding will traverse the DOM tree upwards until it finds the
        nearest parent <span class="inline-code">router</span> and will use that <span class="inline-code">router</span> to trigger its state change when appropriate.</p>

      <div class="note"><span class="label">NOTE:</span> <span class="inline-code">$route</span> binding has many more available options and features. For the full run-down take a look at the
        <a href="/api/routing#route-binding" data-bind="$route">route binding API documentation</a>.</div>

      <div class="figure no-title">
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/routing3.png"></div>
        </div>
      </div>

      <p>If you click logout, you should notice it sends us back to the login page.</p>

      <p>Now you know the basics of setting up a <span class="inline-code">router</span>, creating an <span class="inline-code">outlet</span>, and manipulating the route either explicitly of via a <span class="inline-code">$route</span>
        binding.</p>

      <p>Thats it for this part of the tutorial...in the next (and final) part we will finish up the remaining features and show how broadcastables and receivables are a great way to share state/data between your viewModels.</p>
    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "TodoMVC Routing",
  "description": "",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction" },
    { "anchor": "viewModel-router",
      "title": "viewModel and router" },
    { "anchor": "outlet",
      "title": "Creating an outlet",
      "subSections": [
        { "anchor": "outlet-views",
          "title": "Creating outlet views" },
        { "anchor": "changing-outlet",
          "title": "Changing the outlet" }
      ] },
    { "anchor": "manipulating-route",
      "title": "Manipulating the Route" }
  ]
}
</div>