<article>
  
  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>Getting started with footwork is best done with a real application. In this tutorial we will be covering the creation of a TODO list app.</p>
      <p>Specifically, in relation to footwork.js we will cover the following topics:</p>
      <ul>
        <li>Downloading dependencies and setting up an environment to use footwork.</li>
        <li>App instantiation.</li>
        <li>RequireJS usage for automatic dependency management.</li>
        <li>&lt;viewModel&gt; wrapping of HTML and 2-way binding.</li>
        <li>&lt;custom-component&gt; creation and usage.</li>
        <li>Broadcastable and receivable usage.</li>
        <li>Routing and state initialization.</li>
      </ul>
    </div>
  </section>

  <a id="getting-started" class="section-anchor"></a>
  <section name="getting-started">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Getting Started</h1>
    </header>
    <div class="content">
      <p>This tutorial has a companion repository on github which houses the source. It is recommended that you follow along and play with the code as you progress through the tutorial.</p>

      <p>If you wish to follow along and run the tutorial code it is assumed you have a web server to host the tutorial on, and git installed. You can also optionally follow
        along by viewing the live application at the demo addresses shown at the top of each step.</p>

      <div class="workspace-setup">
        <div class="title">
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com" target="_blank">Live Demo</a>
          <p>You can clone the <a href="https://github.com/reflectiveSingleton/todo-tutorial" target="_blank">tutorial repo</a> with the following command:</p>
        </div>
        <div class="content">
          <pre><code class="bash">git clone https://github.com/reflectiveSingleton/todo-tutorial.git</code></pre>
        </div>
      </div>

      <p>This repo has all of the assets needed to run the application. You may also notice it makes use of <a href="http://bower.io/" target="_blank">bower</a> for
        package management and <a href="http://lesscss.org/#client-side-usage" target="_blank">less.js</a> for CSS. It is not necessary to know anything about
        these in order to use this tutorial however they are both great tools worthy of checking out.</p>
      
      <p>For reasons of brevity this tutorial will not cover the creation of the CSS/LESS, they are included for you in the repository. Also of note, the javascript runtime of
        LessCSS is used so that no re-compile step is required if/when you alter the LESS.</p>

      <div class="note"><span class="label">NOTE:</span> Do not rely on the javascript runtime of LESS when publishing your application on the internet, it is
        always recommended that you incorporate a build process in order to deploy normal CSS files to a production environment.</div></p>
    </div>
  </section>

  <a id="prerequisites" class="section-anchor"></a>
  <section name="prerequisites">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Prerequisites</h2>
    </header>
    <div class="content">
      <p>This tutorial assumes a basic understanding of the following topics:</p>
      
      <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li>Javascript</li>
        <li>
          <p>Knockout.js <a href="http://knockoutjs.com/documentation/observables.html#mvvm-and-view-models" target="_blank">MVVM</a> and <a href="http://knockoutjs.com/documentation/binding-syntax.html" target="_blank">data-binding</a> *</p>
          <div class="note"><span class="label">NOTE*:</span> It is helpful if you have an understanding of knockout
            <a href="http://knockoutjs.com/documentation/observables.html#mvvm-and-view-models" target="_blank">MVVM</a> and <a href="http://knockoutjs.com/documentation/binding-syntax.html" target="_blank">data-binding</a> however you can probably get through this tutorial without having used them before.</div>
        </li>
      </ul>

      <p>If you have questions unanswered by this tutorial consult the <a href="/api" data-bind="$route">footwork API documentation</a>. If that does not answer your question, check the <a href="http://knockoutjs.com/documentation/introduction.html" target="_blank">knockout.js documentation</a>. Footwork at
        its core is just a superset of knockout, extended from the <span class="inline-code">ko</span> (knockout) object itself. Any undocumented features found in footwork are outlined there.</p>

      <p>That said, this tutorial is written with the mindset of standing on its own and you likely won't need the reference material.</p>
    </div>
  </section>

  <a id="setup" class="section-anchor"></a>
  <section name="setup">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Setup</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/setup" target="_blank">Live Demo</a>
          <p>After cloning the repository you are ready to get started, begin by checking out the <span class="inline-code">setup</span> branch:</p>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f setup</code></pre>
        </div>
      </div>

      <p>This will set your workspace up with the base application structure and code. Open up the page in your browser and you won't see anything too interesting just yet...but we'll get to that.</p>
      <div class="figure">
        <div class="title">Initial App View</div>
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/setup0.png" alt="Base application structure" title="Base application structure"></div>
        </div>
      </div>

      <p>The markup itself is also nothing special, just some basic HTML:</p>
<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;!-- ... --&gt;
    &lt;script src="/bower_components/footwork/dist/footwork-all.js"&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;main&gt;
      &lt;form&gt;
        &lt;input type="text" name="thingToDo" placeholder="What needs to be done?"&gt;
        &lt;input type="submit" value="Add Item" class="button"&gt;
      &lt;/form&gt;
      &lt;div class="todo-list"&gt;
        Nothing to do.
      &lt;/div&gt;
    &lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

      <p>The only thing of note here is the <span class="inline-code">&lt;script&gt;</span> tag which is pulling in footwork. The path to it is mostly insignificant, just
      pointing to the bower_components folder (where bower installs footwork by default). What is significant is what build it is using, this is denoted by the postfix <span class="inline-code">-all</span>.
      This build embeds all of the dependencies footwork requires into one easy to use file. For the purposes of this tutorial we will be using this version but note that
       <a href="https://github.com/reflectiveSingleton/footwork/tree/master/dist#readme" target="_blank">others are available</a> which may fit your needs better.</p>

      <p>So what does this get us? Well we have footwork being included and some basic markup with a form to add a todo item, but no actual behavior or code to back it up. If you hit submit on the form
      it will do a normal form request which refreshes the entire page and doesn't do much else. Now it's time to bootstrap footwork and introduce the first important concept, the <span class="inline-code">viewModel</span>.</p>

    </div>
  </section>

  <a id="base-app" class="section-anchor"></a>
  <section name="base-app">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Base Application</h1>
    </header>
    <div class="content">

      <p>We are now ready to start creating our application using the provided HTML (and other assets). In footwork the logic/behavior in your application is primarily driven by
      bindings between your markup and its viewModel. These bindings are the 2-way connections between your HTML and the viewModel it is bound against.</p>

      <p>This means any updates to form elements, or any other events on elements a viewModel is bound with are communicated to/triggered on it via the bindings you declare in the HTML/markup.</p>
      
      <h3>From the <a href="/api/viewModel" data-bind="$route">API documentation on viewModels</a>:</h3>
      
      <div class="note"><em>A viewModel can be thought of as a container object that houses all of the logic and data with which your template/HTML/DOM binds to.</em></div>

      <p>Note that the bindings in your HTML should not contain code/logic, rather you should try and think of them as merely the <em>pointers</em> to the code
      contained within your viewModel. By doing this you avoid the trap of tightly coupling your HTML to the business logic of your application. This enables many benefits, most notably:</p>
      <ul>
        <li>Very little/no coupling between your HTML and its business logic. This makes refactors or changing things much easier.</li>
        <li>It is trivial when debuging to trace behavior back to its source code, the bindings point the way.</li>
        <li>The expressive binding syntax makes creating and composing behavior easier.</li>
        <li>Easy testing of your viewModels and its business logic, independently of the HTML/markup.</li>
      </ul>
    </div>
  </section>

  <a id="creating-the-app" class="section-anchor"></a>
  <section name="creating-the-app">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Creating the Application</h2>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/baseApplication" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/setup...baseApplication" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f baseApplication</code></pre>
        </div>
      </div>

      <p>When creating an application it helps to think about what pieces of your markup can be subdivided. Those subdivisions are good starting points to create code/behavior (viewModels) for. Looking at our current markup,
      the obvious starting point is the form to create a new Todo. We need to create a viewModel (which if you remember, contains the business logic of our UI) for the form to bind against so that we can have it 'do things'
      (yes, that is a highly technical term).</p>
      <p>So to start off lets look at our Todo form and see what bindings it needs...</p>

      <h3>We need a <span class="inline-code">value:</span> binding for the text input and a <span class="inline-code">submit:</span> event binding for the form:</h3>
<div class="file-location">/index.html</div>
<pre>
<code class="html">&lt;!-- ... --&gt;
&lt;form data-bind="submit: submitForm"&gt;
  &lt;input type="text" name="thingToDo" data-bind="value: thingToDo" placeholder="What needs to be done?"&gt;
  &lt;input type="submit" value="Add Item" class="button"&gt;
&lt;/form&gt;
&lt;!-- ... --&gt;</code></pre>
      <div class="note"><span class="label">NOTE:</span> The full list of available bindings is listed on the <a href="http://knockoutjs.com/documentation/introduction.html" target="_blank">knockout.js documentation</a>.
      Remember, footwork is a superset of knockout so it also contains all of the features of knockout, including its binding capabilities. You can also 
      <a href="http://knockoutjs.com/documentation/custom-bindings.html" target="_blank">create your own bindings</a>, but that is out of scope for this tutorial.</div>
      
      <p>Now the form will trigger the <span class="inline-code">submitForm</span> method on the viewModel whenever the form is submitted, and the value of the text input is bound to
        the <span class="inline-code">thingToDo</span> observable on the viewModel.</p>

      <p>The first thing we should look at after creating our form HTML and bindings is what code those bindings dictate we need in our viewModel.</p>

      <p>viewModels are created with the <span class="inline-code">fw.viewModel()</span> factory method. You can
        read about them in detail on the <a href="/api/viewModel" data-bind="$route">viewModel API docs</a>, for our Todo form this viewModel will suffice</p>
      
<div class="file-location">/scripts/viewModels/TodoForm.js</div>
<pre><code class="javascript">fw.viewModel({
  namespace: 'TodoForm', // the name to register the viewModel as
  autoRegister: true, // tells footwork to use this viewModel for any 'TodoForm' viewModels
  initialize: function() {
    // The observable which stores the current thingToDo form text
    this.thingToDo = fw.observable();

    // Method/Action we want triggered when the form is submitted
    this.submitForm = function() {
      console.info('TodoForm submit action triggered');
    };
  }
});</code></pre>

    <h3>In our main application file we start the app:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// tell footwork to startup and begin binding
fw.start();
</code></pre>
      <div class="note"><span class="label">NOTE:</span> Later on this tutorial covers how to convert these (the viewModel and HTML/template) into AMD/RequireJS modules so that foorwork can automatically load them as necessary for you. For
      now, we are simply registering (caching) them manually.</div>

      <h3>And finally, we add the <span class="inline-code">&lt;script&gt;</span> tags to reference our application file and viewModel at the bottom of our <span class="inline-code">index.html</span>:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">    &lt;!-- ... --&gt;
    &lt;script src="scripts/viewModels/TodoForm.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>Now we refresh the page and expect to have our HTML todo form bound to the Todo viewModel. But instead we see an error in the console:</p>
      <div class="figure no-title">
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/baseApplication0.png" alt="Binding error" title="Binding error"></div>
        </div>
      </div>

      <p>So this is telling us it can't find the method/property for the <span class="inline-code">submit:</span> binding on our viewModel,
        why? Well we forgot one critical detail, we need to tell footwork which viewModel to bind our HTML form with. We can do this by wrapping our form
        with the <span class="inline-code">&lt;viewModel&gt;</span> declarative syntax like so:</p>

<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
&lt;viewModel module="TodoForm"&gt;
  &lt;form data-bind="submit: submitForm"&gt;
    &lt;input type="text" name="thingToDo" data-bind="value: thingToDo" placeholder="What needs to be done?"&gt;
    &lt;input type="submit" value="Add Item" class="button"&gt;
  &lt;/form&gt;
&lt;/viewModel&gt;
&lt;!-- ... --&gt;</code></pre>

      <p>Now footwork will know to load the <span class="inline-code">TodoForm</span> viewModel and what HTML to bind it with. Lets refresh the page once more...there is no error this time, great!
        Press the <span class="inline-code">Add Item</span> button, you should see the console spring to life:</p>
      <div class="figure no-title">
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/baseApplication1.png"></div>
        </div>
      </div>
      <p>Excellent, this lets us know our application is initializing properly and our form is binding to the viewModel...</p>
    </div>
  </section>

  <a id="creating-todos" class="section-anchor"></a>
  <section name="creating-todos">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Creating Todos</h2>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/creatingTodos" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/baseApplication...creatingTodos" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f creatingTodos</code></pre>
        </div>
      </div>

      <p>Now that our form is wired up to the viewModel, lets work on creating the actual Todo entries.</p>
      
      <p>Looking at the HTML we see that the todo list is outside of the form. This list will contain not only the list of todo items...but any associated data and behavior related to that list. This
      listing is another good 'section' to make into a separate viewModel.</p>
      
      <h3>Start by wrapping the <span class="inline-code">class="todo-list"</span> element with a viewModel and add the appropriate bindings:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
&lt;viewModel module="TodoList"&gt;
  &lt;div class="todo-list"&gt;
    &lt;div class="todos" data-bind="foreach: todos"&gt;
      &lt;div class="todo" data-bind="text: thingToDo"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/viewModel&gt;
&lt;!-- ... --&gt;</code></pre>

      <h3>And now that our list markup has been created, we can make the <span class="inline-code">TodoList</span> viewModel it will bind against:</h3>
<div class="file-location">/scripts/viewModels/TodoList.js</div>
<pre><code class="javascript">fw.viewModel({
  namespace: 'TodoList',
  autoRegister: true,
  initialize: function() {
    // observable array to store a new TodoItem instance for each todo entry
    this.todos = fw.observableArray();
  }
});</code></pre>

      <h3>One more viewModel is needed...for each individual <span class="inline-code">TodoItem</span>:</h3>
<div class="file-location">/scripts/viewModels/TodoItem.js</div>
<pre><code class="javascript">var TodoItem = fw.viewModel({
  namespace: 'TodoItem',
  initialize: function(thingToDo) {
    this.thingToDo = fw.observable(thingToDo);
  }
});</code></pre>
      <div class="note"><span class="label">NOTE:</span> There is one critical difference in the <span class="inline-code">TodoItem</span> viewModel, we are assigning its constructor function to the variable <span class="inline-code">TodoItem</span>.
        This will allow us to construct new <span class="inline-code">TodoItem</span> entries from inside the <span class="inline-code">TodoList</span> when it receives the new data.</div>

      <h3>And finally, we add the <span class="inline-code">&lt;script&gt;</span> tags to reference our new viewModels at the bottom of our <span class="inline-code">index.html</span>:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">    &lt;!-- ... --&gt;
    &lt;script src="scripts/viewModels/TodoForm.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/viewModels/TodoList.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/viewModels/TodoItem.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>Now when we reload the page, nothing much happens still, typing something into the form and clicking submit simply issues
        the console message we saw prior. Lets fix that by making the <span class="inline-code">TodoForm</span>
        tell the <span class="inline-code">TodoList</span> to add a new entry when the user submits the form. You might be wondering
        how that can be accomplished, the viewModels are after all completely separate and we don't even
        have a reference to them. Fear not, namespacing to the rescue!</p>

      <p>In footwork, communication between viewModels/modules (and anything, really) is accomplished via the
        <a href="/api/namespacing" data-bind="$route">namespacing</a> functionality. You may recall from earlier, the
        <span class="inline-code">namespace:</span>
        attribute we gave to each of our <span class="inline-code">viewModel</span> configurations. This namespace is 
        used not only to <span class="inline-code">autoRegister:</span> the viewModel so footwork can know where to find it, but also to facilitate
        various forms of messaging, events, commands, etc.</p>

      <p>It is possibly easier to grasp with an example, so lets go ahead and add the necessary code we need to have the 
        <span class="inline-code">TodoForm</span> tell the <span class="inline-code">TodoList</span> it should add a todo.</p>

      <h3>First we add the code to <span class="inline-code">TodoForm.js</span> which causes the form to tell the 
        <span class="inline-code">TodoList</span> to add a new item when the form is submitted:</h3>
<div class="file-location">/scripts/viewModels/TodoForm.js</div>
<pre><code class="javascript">fw.viewModel({
  namespace: 'TodoForm',
  autoRegister: true,
  initialize: function() {
    this.thingToDo = fw.observable();

    // create the namespace 'channel' we will use to talk to the TodoList
    this.todoListNamespace = fw.namespace('TodoList');

    this.submitForm = function() {
      // The user wishes to add a todo item, lets tell the TodoList what it is
      this.todoListNamespace.publish('newItem', this.thingToDo());

      // clear out the text box so the user can type a new entry
      this.thingToDo('');
    };
  }
});</code></pre>
      <p>What exactly is happening here? Well the first thing of note is the <span class="inline-code">todoListNamespace</span>
        property being created on the viewModel. The namespace instance created here via <span class="inline-code">fw.namespace()</span>
        can be thought of as a way to send and receive messages/commands/etc to/from the <span class="inline-code">TodoList</span> viewModel.</p>
      
      <p>The other important aspect of this code is the <span class="inline-code">todoListNamespace.publish()</span> call. This method call is
        publishing a message to the <span class="inline-code">TodoList</span> passing along the new todo item the user has typed in.</p>
      
      <div class="note"><span class="label">NOTE:</span> For full documentation on what namespaces are capable of in footwork you should read
        the <a href="/api/namespacing" data-bind="$route">namespacing API documentation</a>.</div>

      <p>Ok so now our <span class="inline-code">TodoForm</span> is sending the message to the <span class="inline-code">TodoList</span>, lets
        modify the <span class="inline-code">TodoList</span> so that it can use that data to create new <span class="inline-code">TodoItem</span> entries.</p>

<div class="file-location">/scripts/viewModels/TodoList.js</div>
<pre><code class="javascript">fw.viewModel({
  namespace: 'TodoList',
  autoRegister: true,
  initialize: function() {
    var self = this; // create a reference to this viewModel we can use inside of the callback
    this.todos = fw.observableArray();
    this.$namespace.subscribe('newItem', function(thingToDo) {
      self.todos.push( new TodoItem(thingToDo) );
    });
  }
});</code></pre>
      
      <p><span class="inline-code">self</span> is simply a reference to <span class="inline-code">this</span> (the viewModel) that we can reference inside of the <span class="inline-code">subscribe()</span> callback.</p>
      
      <p>And lastly, note the <span class="inline-code">this.$namespace.subscribe()</span> call. This simply adds a callback for any 'newItem' messages that are
        broadcast for the viewModels <span class="inline-code">$namespace</span> ('TodoList' in this case). This callback pushes a <span class="inline-code">new TodoItem()</span> onto the
        <span class="inline-code">todos</span> observable array. If all is going well when you refresh the page type something into the form and hit enter you should see a new todo entry:</p>
      
      <div class="figure">
        <div class="title">A new todo is created!</div>
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/creatingTodos0.png" alt="What you see after creating a todo" title="What you see after creating a todo"></div>
        </div>
      </div>

      <p>Now we have the very basic functionality of being able to create new todo items and having them rendered to the page. You might be thinking that <span class="inline-code">viewModels</span> are great and all, but at this rate
        we will be writing a single page of HTML to represent our entire app. Not only that, we have to specify and correctly order all of the javascript assets by hand...thats not too modular or robust is it?</p>

      <p>It certainly isn't. In the next section we learn how to split apart our html into separate templates and couple them
        along with their respective viewModel to create fully encapsulated reusable (and testable) <em>components</em>.</p>
    </div>
  </section>

  <a id="components" class="section-anchor"></a>
  <section name="components">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Components</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/components" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/creatingTodos...components" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f components</code></pre>
        </div>
      </div>

      <p>Our <span class="inline-code">viewModels</span> are nicely separated from each other, wouldn't it be nice to split apart the HTML in the same way? Maybe combine the two into a reusable package? Components let you do just that.</p>

      <p>You may have heard about them, and how future browsers will hopefully support them and enable a new world of reusable pieces you can just throw around at will. Well footwork (with the help of knockout) provides exactly
      that. Expressive semantic custom elements, testable and reusable by simply declaring them in your HTML. Did I mention you can nest any number of both <span class="inline-code">viewModel</span> or other <span class="inline-code">components</span>
      within them as well? Even entire applications?</p>

      <div class="note"><span class="label">NOTE:</span> Components are extremely powerful and have many useful features, you can view the full documentation concerning <span class="inline-code">components</span> in the 
      <a href="/api/components" data-bind="$route">API documentation</a>.</div>

      <p>Lets start by componentizing the <span class="inline-code">TodoForm</span>, after all maybe in the future we might want to reuse this form on a different page or possibly in multiple places on the same page. Thankfully, we already
      have our viewModel <span class="inline-code">TodoForm</span> in its own separate file...no additional work needs to be done there just yet.</p>

      <p>We begin by pulling out the <span class="inline-code">TodoForm</span> HTML into its own separate file and replacing it with a declarative custom element (<span class="inline-code">&lt;todoform&gt;&lt;/todoform&gt;</span> in this case,
      although it can be anything you want that is a non-standard tagName. Valid letters include lower-case letters and a hyphen).</p>

      <h3>Here is the <span class="inline-code">TodoForm</span> extracted out from the <span class="inline-code">index.html</span> and placed in its own file:</h3>
<div class="file-location">/scripts/templates/TodoForm.html</div>
<pre><code class="html">&lt;form data-bind="submit: submitForm"&gt;
  &lt;input type="text" name="thingToDo" data-bind="value: thingToDo" placeholder="What needs to be done?"&gt;
  &lt;input type="submit" value="Add Item" class="button"&gt;
&lt;/form&gt;</code></pre>

      <h3>And replace it with our custom element:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">  &lt;!-- ... --&gt;
    &lt;main&gt;
      &lt;todoform&gt;&lt;/todoform&gt; &lt;!-- Our new custom element --&gt;
      &lt;viewModel module="TodoList"&gt;
  &lt;!-- ... --&gt;</code></pre>

      <p>Having done that, if we reload the page we see another error in the console:</p>
      
      <div class="figure no-title">
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/components0.png"></div>
        </div>
      </div>

      <p>Now that both the HTML form and its viewModel are in their own files we have what we need to turn it into a component. In the next section we start by telling footwork how it can build the component and access both the template and viewModel.</p>

    </div>
  </section>

  <a id="automatic-loading" class="section-anchor"></a>
  <section name="automatic-loading">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Automatic Loading</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/automaticLoading" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/components...automaticLoading" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f automaticLoading</code></pre>
        </div>
      </div>

      <p>So now that we have our HTML form in its own file, we need to AMD-ify the javascript assets and inform footwork on where it can find all of the files.</p>

      <p>There are a few things left to do, they are as follows:</p>
      <ul>
        <li>Convert our form viewModel into a RequireJS/AMD javascript module.</li>
        <li>Convert our main <span class="inline-code">app.js</span> into a RequireJS/AMD main module.</li>
        <li>Tell footwork where our component viewModel and template files are located.</li>
        <li>Add the RequireJS main script tag to our <span class="inline-code">index.html</span></li>
      </ul>
      <div class="note">
        <p><span class="label">NOTE:</span> We also will be converting the remaining javascript files into AMD modules as well, RequireJS/AMD loading is mostly an all-or-nothing situation.</p>
        <p>To enable RequireJS to track and manage our dependencies everything it needs (and everything it loads) will need to be converted. For purposes of brevity, only the
          <span class="inline-code">TodoForm</span> module conversion will be outlined here...the others follow the exact same pattern, you can check out the code in order to view them.</p>
      </div>

      <h3>We start by turning our form viewModel into a RequireJS/AMD module:</h3>
<div class="file-location">/scripts/viewModels/TodoForm.js</div>
<pre><code class="javascript">define(['footwork'],
  function(fw) {
    return fw.viewModel({
      namespace: 'TodoForm',
      initialize: function() {
        // ...
      }
    });
  }
);</code></pre>
      <div class="note"><span class="label">NOTE:</span> Everything else about this viewModel is essentially unchanged, we just needed to add the RequireJS wrapper
        around it which lists footwork as a dependency and return the viewModel constructor created by <span class="inline-code">fw.viewModel()</span>.</div>

      <h3>Next, lets convert our <span class="inline-code">app.js</span> file into a RequireJS 'main' module:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">/**
 * Configure RequireJS, telling it where the text plugin (used to load templates) and
 * footwork are located.
 */
requirejs.config({
  paths: {
    "text": "/bower_components/requirejs-text/text",
    "footwork": "/bower_components/footwork/dist/footwork-all"
  }
});

require([ 'footwork' ],
  function(fw) {
    // tell footwork to startup and begin binding
    fw.start(); 
  }
);</code></pre>
      <div class="note"><span class="label">NOTE:</span> Once again everything else about this file is essentially unchanged, we just needed to add the RequireJS wrapper around it.</div>

      <h3>Now we have to tell footwork where it can find our component and viewModel assets:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// ...
require([ 'footwork' ],
  function(fw) {
    // footwork will append the filename to the path if you provide a trailing '/'
    fw.viewModels.registerLocation('TodoList', '/scripts/viewModels/'); // /scripts/viewModels/TodoList.js

    /**
     * Here we provide the entire filename to footwork because the lowercase
     * 'todoform' does not match the file names on disk.
     */
    fw.components.registerLocation('todoform', {
      viewModel: '/scripts/viewModels/TodoForm.js',
      template: '/scripts/templates/TodoForm.html'
    });

    // tell footwork to startup and begin binding
    fw.start(); 
  }
);</code></pre>
      <p class="note"><span class="label">NOTE:</span> For full documentation on how you can specify where these assets are located take a look at the
      <a href="/api/components#loading-registering" data-bind="$route">components AMD</a> and <a href="/api/viewModel#loading-registering" data-bind="$route">viewModel AMD</a> sections of the API docs.</p>

      <p>So by using <span class="inline-code">fw.components.registerLocation()</span> and <span class="inline-code">fw.viewModels.registerLocation()</span> we are able to to footwork where it can
      find our modules.</p>

    </div>
  </section>
</article>

<div id="metaData">
{
  "title": "TodoMVC Tutorial",
  "description": "",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction" },
    { "anchor": "getting-started",
      "title": "Getting Started",
      "subSections": [
        { "anchor": "prerequisites",
          "title": "Prerequisites" }
      ] },
    { "anchor": "setup",
      "title": "Setup" },
    { "anchor": "base-app",
      "title": "Base Application",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "creating-the-app",
          "title": "Creating the App" },
        { "anchor": "creating-todos",
          "title": "Creating Todos" }
      ] },
    { "anchor": "components",
      "title": "Components",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "automatic-loading",
          "title": "Automatic Loading" }
      ] }
  ]
}
</div>