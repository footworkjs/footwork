<article>
  
  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>Getting started with footwork is best done with a real application. In this tutorial we will be covering the creation of a TODO list app.</p>
      <p>Specifically, in relation to footwork.js we will cover the following topics:</p>
      <ul>
        <li>Downloading dependencies and setting up an environment to use footwork.</li>
        <li>App instantiation.</li>
        <li>RequireJS usage for automatic dependency management.</li>
        <li>&lt;viewModel&gt; wrapping of HTML and 2-way binding.</li>
        <li>&lt;custom-component&gt; creation and usage.</li>
        <li>Broadcastable and receivable usage.</li>
        <li>Routing and state initialization.</li>
      </ul>
    </div>
  </section>

  <a id="getting-started" class="section-anchor"></a>
  <section name="getting-started">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Getting Started</h1>
    </header>
    <div class="content">
      <p>This tutorial has a companion repository on github which houses the source. It is recommended that you follow along and play with the code as you progress through the tutorial.</p>

      <p>If you wish to follow along and run the tutorial code it is assumed you have a web server to host the tutorial on, and git installed. This tutorial will also not be covering
        the setup and configuration of your web server to host the files, it is assumed you are capable of handling that as well.</p>

      <div class="note"><span class="label">NOTE:</span> You can also optionally follow along by viewing the Live Demo link shown at the top of each step.</div>

      <div class="workspace-setup">
        <div class="title">
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com" target="_blank">Live Demo</a>
          <p>You can clone the <a href="https://github.com/reflectiveSingleton/todo-tutorial" target="_blank">tutorial repo</a> with the following command:</p>
        </div>
        <div class="content">
          <pre><code class="bash">git clone https://github.com/reflectiveSingleton/todo-tutorial.git</code></pre>
        </div>
      </div>

      <p>This repo has all of the assets needed to run the application. You may also notice it makes use of <a href="http://bower.io/" target="_blank">bower</a> for
        package management and <a href="http://lesscss.org/#client-side-usage" target="_blank">less.js</a> for CSS. It is not necessary to know anything about (nor have installed)
        these in order to use this tutorial however they are both great tools worthy of checking out.</p>
      
      <p>For reasons of brevity this tutorial will not cover the creation of the CSS/LESS, they are included for you in the repository. Also of note, the javascript runtime of
        LessCSS is used so that no re-compile step is required if/when you alter the LESS.</p>

      <div class="note"><span class="label">NOTE:</span> Do not rely on the javascript runtime of LESS when publishing your application on the internet, it is
        always recommended that you incorporate a build process in order to deploy normal CSS files to a production environment.</div></p>
    </div>
  </section>

  <a id="prerequisites" class="section-anchor"></a>
  <section name="prerequisites">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Prerequisites</h2>
    </header>
    <div class="content">
      <p>This tutorial assumes a basic understanding of the following topics:</p>
      
      <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li>Javascript</li>
        <li>
          <p>Knockout.js <a href="http://knockoutjs.com/documentation/observables.html#mvvm-and-view-models" target="_blank">MVVM</a> and <a href="http://knockoutjs.com/documentation/binding-syntax.html" target="_blank">data-binding</a> *</p>
          <div class="note"><span class="label">NOTE*:</span> It is helpful if you have an understanding of knockout
            <a href="http://knockoutjs.com/documentation/observables.html#mvvm-and-view-models" target="_blank">MVVM</a> and <a href="http://knockoutjs.com/documentation/binding-syntax.html" target="_blank">data-binding</a> however you can probably get through this tutorial without having used them before.</div>
        </li>
      </ul>

      <p>If you have questions unanswered by this tutorial consult the <a href="/api" data-bind="$route">footwork API documentation</a>. If that does not answer your question, check the <a href="http://knockoutjs.com/documentation/introduction.html" target="_blank">knockout.js documentation</a>. Footwork at
        its core is just a superset of knockout, extended from the <span class="inline-code">ko</span> (knockout) object itself. Any undocumented features found in footwork are outlined there.</p>

      <p>That said, this tutorial is written with the mindset of standing on its own and you likely won't need the reference material to complete it.</p>
    </div>
  </section>

  <a id="setup" class="section-anchor"></a>
  <section name="setup">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Setup</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/setup" target="_blank">Live Demo</a>
          <p>After cloning the repository you are ready to get started, begin by checking out the <span class="inline-code">setup</span> branch:</p>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f setup</code></pre>
        </div>
      </div>

      <p>This will set your workspace up with the base application structure and code. Open up the page in your browser and you won't see anything too interesting just yet...but we'll get to that.</p>
      <div class="figure">
        <div class="title">Initial App View</div>
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/setup0.png" alt="Base application structure" title="Base application structure"></div>
        </div>
      </div>

      <p>The markup itself is also nothing special, just some basic HTML:</p>
<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;!-- ... --&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;main&gt;
      &lt;form&gt;
        &lt;input type="text" name="thingToDo" placeholder="What needs to be done?" autofocus&gt;
        &lt;input type="submit" value="Add Item" class="button"&gt;
      &lt;/form&gt;
      &lt;div class="todo-list"&gt;
        Nothing to do.
      &lt;/div&gt;
    &lt;/main&gt;
    &lt;script src="/bower_components/footwork/dist/footwork-all.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

      <p>The only thing of note here is the <span class="inline-code">&lt;script&gt;</span> tag which is pulling in footwork. The path to it is mostly insignificant, it is 
        pointing to the bower_components folder (where bower installs footwork by default). What is significant is what build it is using, this is denoted by the postfix <span class="inline-code">-all</span>.
        This build embeds all of the dependencies footwork requires into one easy to use file. For the purposes of this tutorial we will be using this version but note that
        <a href="https://github.com/reflectiveSingleton/footwork/tree/master/dist#readme" target="_blank">others are available</a> which may fit your needs better.</p>

      <p>So what does this get us? Well we have footwork being included and some basic markup with a form to add a todo item, but no actual behavior or code to back it up. If you hit submit on the form
        it will do a normal form request which refreshes the entire page and doesn't do much else. Now it's time to bootstrap footwork and introduce the first important concept, the <span class="inline-code">viewModel</span>.</p>

    </div>
  </section>

  <a id="base-app" class="section-anchor"></a>
  <section name="base-app">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Base Application</h1>
    </header>
    <div class="content">

      <p>We are now ready to start creating our application using the provided HTML (and other assets). In footwork the logic/behavior in your application is primarily driven by
        bindings between your markup and its viewModel. These bindings are the 2-way connections between your HTML and the viewModel it is bound against.</p>

      <p>This means any updates to form elements, or any other events on elements a viewModel is bound with are communicated to/triggered on it via the bindings you declare in the HTML/markup.</p>
      
      <h3>From the <a href="/api/viewModel" data-bind="$route">API documentation on viewModels</a>:</h3>
      
      <div class="note"><em>A viewModel can be thought of as a container object that houses all of the logic and data with which your template/HTML/DOM binds to.</em></div>

      <p>Note that the bindings in your HTML should not contain code/logic, rather you should try and think of them as merely the <em>pointers</em> to the code
        contained within your viewModel. By doing this you avoid the trap of tightly coupling your HTML to the business logic of your application. This enables many benefits, most notably:</p>
      
      <ul>
        <li>Very little/no coupling between your HTML and its business logic. This makes refactors or changing things much easier.</li>
        <li>It is trivial when debuging to trace behavior back to its source code, the bindings point the way.</li>
        <li>The expressive binding syntax makes creating and composing behavior easier to do/comprehend.</li>
        <li>Ensures testability of your viewModels and its business logic, independently of the HTML/markup.</li>
      </ul>
    </div>
  </section>

  <a id="creating-the-app" class="section-anchor"></a>
  <section name="creating-the-app">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Creating the Application</h2>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/baseApplication" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/setup...baseApplication" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f baseApplication</code></pre>
        </div>
      </div>

      <p>When creating an application it helps to think about what pieces of your markup can be subdivided. Those subdivisions are good starting points to create code/behavior (viewModels) for. Looking at our current markup,
        the obvious starting point is the form to create a new Todo. We need to create a viewModel (which if you remember, contains the business logic of our UI) for the form to bind against so that we can have it 'do things'
        (yes, that is a highly technical term).</p>
      
      <p>So to start off lets look at our Todo form and see what bindings it needs...</p>

      <h3>We need a <span class="inline-code">value:</span> binding for the text input and a <span class="inline-code">submit:</span> event binding for the form:</h3>
<div class="file-location">/index.html</div>
<pre>
<code class="html">&lt;!-- ... --&gt;
&lt;form data-bind="submit: submitForm"&gt;
  &lt;input type="text" name="thingToDo" data-bind="value: thingToDo" placeholder="What needs to be done?"&gt;
  &lt;input type="submit" value="Add Item" class="button"&gt;
&lt;/form&gt;
&lt;!-- ... --&gt;</code></pre>

      <div class="note"><span class="label">NOTE:</span> The full list of available bindings is listed on the <a href="http://knockoutjs.com/documentation/introduction.html" target="_blank">knockout.js documentation</a>.
        Remember, footwork is a superset of knockout so it also contains all of the features of knockout, including its binding capabilities. You can also 
        <a href="http://knockoutjs.com/documentation/custom-bindings.html" target="_blank">create your own bindings</a>, but that is out of scope for this tutorial.</div>
      
      <p>Now the form will trigger the <span class="inline-code">submitForm</span> method on the viewModel whenever the form is submitted, and the value of the text input is bound to
        the <span class="inline-code">thingToDo</span> observable on the viewModel.</p>

      <p>The first thing we should look at after creating our form HTML and bindings is what code those bindings dictate we need in our viewModel.</p>

      <p>viewModels are created with the <span class="inline-code">fw.viewModel()</span> factory method. You can
        read about them in detail on the <a href="/api/viewModel" data-bind="$route">viewModel API docs</a>.</p>
      
      <h3>For our todo form this viewModel will suffice:</h3>
<div class="file-location">/scripts/viewModels/TodoForm.js</div>
<pre><code class="javascript">var TodoForm = fw.viewModel({
  namespace: 'TodoForm', // the name to register the viewModel as
  autoRegister: true, // tells footwork to use this viewModel for any 'TodoForm' viewModels
  initialize: function() {
    // The observable which stores the current thingToDo form text
    this.thingToDo = fw.observable();

    // Method/Action we want triggered when the form is submitted
    this.submitForm = function() {
      console.info('TodoForm submit action triggered');
    };
  }
});</code></pre>

    <h3>In our main application file we start the app:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// tell footwork to startup and begin binding
fw.start();
</code></pre>
      <div class="note"><span class="label">NOTE:</span> Later on this tutorial covers how to convert these (the viewModel and HTML/template) into AMD/RequireJS modules so that foorwork can automatically load them as necessary for you. For
      now, we are simply registering (caching) them manually.</div>

      <h3>And finally, we add the <span class="inline-code">&lt;script&gt;</span> tags to reference our application file and viewModel at the bottom of our <span class="inline-code">index.html</span>:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">    &lt;!-- ... --&gt;
    &lt;script src="scripts/viewModels/TodoForm.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>Now we refresh the page and expect to have our HTML todo form bound to the Todo viewModel. But instead we see an error in the console:</p>
      <div class="figure no-title">
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/baseApplication0.png" alt="Binding error" title="Binding error"></div>
        </div>
      </div>

      <p>So this is telling us it can't find the method/property for the <span class="inline-code">submit:</span> binding on our viewModel,
        why? Well we forgot one critical detail, we need to tell footwork which viewModel to bind our HTML form with. We can do this by wrapping our form
        with the <span class="inline-code">&lt;viewModel&gt;</span> declarative syntax like so:</p>

<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
&lt;viewModel module="TodoForm"&gt;
  &lt;form data-bind="submit: submitForm"&gt;
    &lt;input type="text" name="thingToDo" data-bind="value: thingToDo" placeholder="What needs to be done?"&gt;
    &lt;input type="submit" value="Add Item" class="button"&gt;
  &lt;/form&gt;
&lt;/viewModel&gt;
&lt;!-- ... --&gt;</code></pre>

      <p>Now footwork will know to load the <span class="inline-code">TodoForm</span> viewModel and what HTML to bind it with. Lets refresh the page once more...there is no error this time, great!
        Press the <span class="inline-code">Add Item</span> button, you should see the console spring to life:</p>

      <div class="figure no-title">
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/baseApplication1.png"></div>
        </div>
      </div>

      <p>Excellent, this lets us know our application is initializing properly and our form is binding to the viewModel...</p>
    </div>
  </section>

  <a id="creating-todos" class="section-anchor"></a>
  <section name="creating-todos">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Creating Todos</h2>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/creatingTodos" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/baseApplication...creatingTodos" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f creatingTodos</code></pre>
        </div>
      </div>

      <p>Now that our form is wired up to the viewModel, lets work on creating the actual Todo entries.</p>
      
      <p>Looking at the HTML we see that the todo list is outside of the form. This list will contain not only the list of todo items...but any associated data and behavior related to that list. This
        listing is another good 'section' to make into a separate viewModel.</p>
      
      <h3>Start by wrapping the <span class="inline-code">class="todo-list"</span> element with a viewModel and add the appropriate bindings:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
&lt;viewModel module="TodoList"&gt;
  &lt;div class="todo-list"&gt;
    &lt;div class="todos" data-bind="foreach: todos"&gt;
      &lt;div class="todo" data-bind="text: thingToDo"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/viewModel&gt;
&lt;!-- ... --&gt;</code></pre>

      <h3>And now that our list markup has been created, we can make the <span class="inline-code">TodoList</span> viewModel it will bind against:</h3>
<div class="file-location">/scripts/viewModels/TodoList.js</div>
<pre><code class="javascript">var TodoList = fw.viewModel({
  namespace: 'TodoList',
  autoRegister: true,
  initialize: function() {
    // observable array to store a new TodoItem instance for each todo entry
    this.todos = fw.observableArray();
  }
});</code></pre>

      <h3>One more viewModel is needed...the one we will use for each individual <span class="inline-code">TodoItem</span>:</h3>
<div class="file-location">/scripts/viewModels/TodoItem.js</div>
<pre><code class="javascript">var TodoItem = fw.viewModel({
  namespace: 'TodoItem',
  initialize: function(thingToDo) {
    this.thingToDo = fw.observable(thingToDo);
  }
});</code></pre>

      <h3>And finally, we add the <span class="inline-code">&lt;script&gt;</span> tags to reference our new viewModels at the bottom of our <span class="inline-code">index.html</span>:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">    &lt;!-- ... --&gt;
    &lt;script src="scripts/viewModels/TodoForm.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/viewModels/TodoList.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/viewModels/TodoItem.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>Now when we reload the page, nothing much happens still, typing something into the form and clicking submit simply issues
        the console message we saw prior. Lets fix that by making the <span class="inline-code">TodoForm</span>
        tell the <span class="inline-code">TodoList</span> to add a new entry when the user submits the form.</p>

      <p>You might be wondering how that can be accomplished, the viewModels are after all completely separate and we don't even
        have a reference to them. We only have references to their constructor functions, which doesn't get us much. We can only create new instances with that, not
        get references to current instances. But fear not, namespace-based <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank">CQRS</a> to the rescue!</p>

      <p>In footwork, communication between viewModels/modules (and anything, really) is accomplished via the
        <a href="/api/namespacing" data-bind="$route">namespacing</a> functionality. You may recall from earlier, the
        <span class="inline-code">namespace:</span>
        attribute we gave to each of our <span class="inline-code">viewModel</span> configurations. This namespace is 
        used not only to <span class="inline-code">autoRegister:</span> the viewModel so footwork can know where to find it, but also to facilitate
        various forms of messaging, events, commands, etc.</p>

      <p>It is possibly easier to grasp with an example, so lets go ahead and add the necessary code we need to have the 
        <span class="inline-code">TodoForm</span> tell the <span class="inline-code">TodoList</span> it should add a new <span class="inline-code">TodoItem</span>.</p>

      <h3>First we add code to <span class="inline-code">TodoForm.js</span> which causes the form to tell the 
        <span class="inline-code">TodoList</span> to add a new item when the form is submitted:</h3>
<div class="file-location">/scripts/viewModels/TodoForm.js</div>
<pre><code class="javascript">var TodoForm = fw.viewModel({
  namespace: 'TodoForm',
  autoRegister: true,
  initialize: function() {
    this.thingToDo = fw.observable();

    // create the namespace 'channel' we will use to talk to the TodoList
    this.todoListNamespace = fw.namespace('TodoList');

    this.submitForm = function() {
      // The user wishes to add a todo item, lets tell the TodoList what it is
      this.todoListNamespace.publish('newItem', this.thingToDo());

      // clear out the text box so the user can type a new entry
      this.thingToDo('');
    };
  }
});</code></pre>
      <p>What exactly is happening here? Well the first thing of note is the <span class="inline-code">todoListNamespace</span>
        property being created on the viewModel. The namespace instance created here via <span class="inline-code">fw.namespace()</span>
        can be thought of as a way to send and receive messages/commands/etc to/from the <span class="inline-code">TodoList</span> viewModel.</p>
      
      <p>The other important aspect of this code is the <span class="inline-code">todoListNamespace.publish()</span> call. This method call is
        publishing a message to the <span class="inline-code">TodoList</span> passing along the new todo item the user has typed in.</p>
      
      <div class="note"><span class="label">NOTE:</span> For full documentation on what namespaces are capable of in footwork you should read
        the <a href="/api/namespacing" data-bind="$route">namespacing API documentation</a>.</div>

      <p>Ok so now our <span class="inline-code">TodoForm</span> is sending the message to the <span class="inline-code">TodoList</span>, lets
        modify the <span class="inline-code">TodoList</span> so that it can receive (listen for) that message and create new <span class="inline-code">TodoItem</span> entries
        based on the data passed to it.</p>

      <h3>We add the <span class="inline-code">$namespace.subscribe()</span> call to subscribe to <span class="inline-code">newItem</span> messages:</h3>
<div class="file-location">/scripts/viewModels/TodoList.js</div>
<pre><code class="javascript">var TodoList = fw.viewModel({
  namespace: 'TodoList',
  autoRegister: true,
  initialize: function() {
    var self = this; // create a reference to this viewModel we can use inside of the callback
    this.todos = fw.observableArray();

    // listen for any 'newItem' messages broadcast on our namespace.
    this.$namespace.subscribe('newItem', function(thingToDo) {
      // new thingToDo was received, lets create a new TodoItem based on it
      self.todos.push( new TodoItem(thingToDo) );
    });
  }
});</code></pre>
      
      <p>And lastly, note the <span class="inline-code">this.$namespace.subscribe()</span> call. This simply adds a callback for any 'newItem' messages that are
        broadcast for the viewModels <span class="inline-code">$namespace</span> ('TodoList' in this case). This callback pushes a <span class="inline-code">new TodoItem()</span> onto the
        <span class="inline-code">todos</span> observable array. If all is going well when you refresh the page, type something into the form, and then hit enter you should see a new todo entry:</p>
      
      <div class="figure">
        <div class="title">A new todo is created!</div>
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/creatingTodos0.png" alt="What you see after creating a todo" title="What you see after creating a todo"></div>
        </div>
      </div>

      <p>Now we have the very basic functionality of being able to create new todo items and having them rendered to the page. You might be thinking that <span class="inline-code">viewModels</span> are great and all, but at this rate
        we will be writing a single page of HTML to represent our entire app. Thats not too modular or robust is it?</p>

      <p>It certainly isn't. In the next section we learn how to split apart our html into separate templates and couple them
        along with their respective viewModel to create fully encapsulated reusable (and testable) <em>components</em>.</p>
    </div>
  </section>

  <a id="components" class="section-anchor"></a>
  <section name="components">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Components</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/components" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/creatingTodos...components" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f components</code></pre>
        </div>
      </div>

      <p>Our <span class="inline-code">viewModels</span> are nicely separated from each other, wouldn't it be nice to split apart the HTML in the same way? Maybe combine the two into a reusable package? Components let you do just that.</p>

      <p>You may have heard about them, and how future browsers will hopefully support them and enable a new world of reusable pieces you can just throw around at will. Well footwork (with the help of knockout) provides exactly
        that. Expressive semantic custom elements, testable and reusable by simply declaring them in your HTML. Did I mention you can nest any number of both <span class="inline-code">viewModel</span> or other <span class="inline-code">components</span>
        within them as well? Even entire applications?</p>

      <div class="note"><span class="label">NOTE:</span> Components are extremely powerful and have many useful features, you can view the full documentation concerning <span class="inline-code">components</span> in the 
        <a href="/api/components" data-bind="$route">API documentation</a>.</div>

      <p>Lets start by componentizing the <span class="inline-code">TodoForm</span>, after all maybe in the future we might want to reuse this form on a different page or possibly in multiple places on the same page. Thankfully, we already
        have our viewModel <span class="inline-code">TodoForm</span> in its own separate file...no additional work needs to be done there just yet.</p>

      <p>We begin by pulling out the <span class="inline-code">TodoForm</span> HTML and replacing it with a declarative custom element (<span class="inline-code">&lt;todoform&gt;&lt;/todoform&gt;</span> in this case,
        although it can be anything you want that is a non-standard tagName. Valid letters include lower-case letters and a hyphen).</p>

      <h3>Replace the form with our custom element:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">  &lt;!-- ... --&gt;
    &lt;main&gt;
      &lt;todoform&gt;&lt;/todoform&gt; &lt;!-- Our new custom element --&gt;
      &lt;viewModel module="TodoList"&gt;
  &lt;!-- ... --&gt;</code></pre>

      <p>Now, where do we put the HTML for the form? In this step of the tutorial we will be registering the component directly with footwork, and for that to be accomplished we need the form embedded in a string variable. Note
        that it is not recommended to do it this way, and in the next section we will be covering how to convert this (and our viewModel) into their AMD/RequireJS counterparts so that footwork can load them
        automatically as needed for you.</p>

      <h3>Register both the template and viewModel with footwork:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">var TodoFormHTML = '&lt;form data-bind="submit: submitForm"&gt;\
  &lt;input type="text" name="thingToDo" data-bind="value: thingToDo" placeholder="What needs to be done?"&gt;\
  &lt;input type="submit" value="Add Item" class="button"&gt;\
&lt;/form&gt;';

fw.components.register('todoform', {
  viewModel: TodoForm,
  template: TodoFormHTML
});

// tell footwork to startup and begin binding
fw.start();</code></pre>

      <p>Having done that, if we reload the page we should not see any error. Now lets try typing in a new todo item, then hit enter, you should see a new todo on the page:</p>
      
      <div class="figure">
        <div class="title">A new todo created with our component todo form:</div>
        <div class="content">
          <div class="image"><img src="images/todo-tutorial/components0.png"></div>
        </div>
      </div>

      <p>Now our application is using a custom element to lookup, compose, and insert our component for us. In the next section we find out how to make this more modular by separating our our HTML into separate files and loading it
        all dynamically via RequireJS/AMD.</p>

    </div>
  </section>

  <a id="amd-requirejs" class="section-anchor"></a>
  <section name="amd-requirejs">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">AMD / RequireJS</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/amd" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/components...amd" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f amd</code></pre>
        </div>
      </div>

      <p>Converting our <span class="inline-code">viewModels</span> and <span class="inline-code">components</span> into RequireJS/AMD modules is very beneficial. It allows footwork
        to automatically load them for you when needed, as well as any dependencies they may have. It also makes it easy for us to place our template HTML in its own separate file.
        This helps us keep both our HTML (markup and bindings) and javascript (business logic) very modularized and separated. Even further, we can still cache any viewModels/components
        that we don't want the client to wait to download if we end up building the javascript before deploying into production (this tutorial will not cover that portion).</p>
      
      <p>In this step we convert our application to use RequireJS and enable footwork to load our assets (both viewModels, and components) dynamically for us at runtime.</p>

      <p>In order to do this we need to do the following things:</p>
      <ul>
        <li>Pull the todo form HTML template out of <span class="inline-code">app.js</span> and put it into its own file.</li>
        <li>Convert our viewModels into RequireJS/AMD javascript modules.</li>
        <li>Convert our <span class="inline-code">app.js</span> into a RequireJS/AMD main module.</li>
        <li>Tell footwork where our viewModels, and components (viewModel + template) are located.</li>
        <li>Add the RequireJS main script tag to our <span class="inline-code">index.html</span></li>
      </ul>
      
      <h3>We start by pulling our form HTML template out of <span class="inline-code">app.js</span> and placing it in its own file:</h3>
<div class="file-location">/scripts/templates/TodoForm.html</div>
<pre><code class="html">&lt;form data-bind="submit: submitForm"&gt;
  &lt;div class="icon-chevron-down"&gt;&lt;/div&gt;
  &lt;input type="text" name="thingToDo" data-bind="value: thingToDo" placeholder="What needs to be done?" autofocus&gt;
  &lt;input type="submit" value="Add Item" class="button"&gt;
&lt;/form&gt;</code></pre>

      <h3>Then we turn our viewModels into RequireJS/AMD modules (TodoForm shown, <a href="https://github.com/reflectiveSingleton/todo-tutorial/tree/amd" target="_blank">see the repo</a>
        for <span class="inline-code"><a href="https://github.com/reflectiveSingleton/todo-tutorial/blob/amd/scripts/viewModels/TodoList.js" target="_blank">TodoList</a></span> and
        <span class="inline-code"><a href="https://github.com/reflectiveSingleton/todo-tutorial/blob/amd/scripts/viewModels/TodoItem.js" target="_blank">TodoItem</a></span>):</h3>
<div class="file-location">/scripts/viewModels/TodoForm.js</div>
<pre><code class="javascript">define(['footwork'],
  function(fw) {
    return fw.viewModel({
      namespace: 'TodoForm',
      initialize: function() {
        // ...
      }
    });
  }
);</code></pre>
      <div class="note"><span class="label">NOTE:</span> Everything else about this viewModel is essentially unchanged, we just needed to add the RequireJS wrapper
        around it which lists footwork as a dependency and return the viewModel constructor created by <span class="inline-code">fw.viewModel()</span>.</div>

      <h3>Next, lets convert our <span class="inline-code">app.js</span> file into a RequireJS 'main' module:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">/**
 * Configure RequireJS, telling it where the text plugin (used to load templates) and
 * footwork are located.
 */
requirejs.config({
  paths: {
    "text": "/bower_components/requirejs-text/text",
    "footwork": "/bower_components/footwork/dist/footwork-all"
  }
});

require([ 'footwork' ],
  function(fw) {
    // tell footwork to startup and begin binding
    fw.start(); 
  }
);</code></pre>
      <div class="note"><span class="label">NOTE:</span> With the exception of adding the config at the top, the only change here is we needed to add the RequireJS wrapper around our code.</div>

      <h3>Now we have to tell footwork where it can find our component and viewModel assets before the app is started:</h3>
<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// ...
require([ 'footwork' ],
  function(fw) {
    // footwork will append the filename to the path if you provide a trailing '/'
    fw.viewModels.registerLocation('TodoList', '/scripts/viewModels/'); // /scripts/viewModels/TodoList.js

    /**
     * Here we provide the entire filename to footwork because the lowercase
     * 'todoform' does not match the file names on disk.
     */
    fw.components.registerLocation('todoform', {
      viewModel: '/scripts/viewModels/TodoForm.js',
      template: '/scripts/templates/TodoForm.html'
    });

    // tell footwork to startup and begin binding
    fw.start(); 
  }
);</code></pre>
      <p class="note"><span class="label">NOTE:</span> For full documentation on how you can specify where these assets are located take a look at the
        <a href="/api/components#loading-registering" data-bind="$route">components AMD</a> and <a href="/api/viewModel#loading-registering" data-bind="$route">viewModel AMD</a> sections of the API docs.</p>

      <p>By using <span class="inline-code">fw.components.registerLocation()</span> and <span class="inline-code">fw.viewModels.registerLocation()</span> we are able to tell footwork where it can
        find our viewModels and component (viewModel + template) assets.</p>
      
      <h3>And finally, we pull out our previous <span class="inline-code">&lt;script&gt;</span> tags and replace them with the RequireJS flavored version:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">      &lt;!-- ... --&gt;
    &lt;/main&gt;
    &lt;script src="bower_components/requirejs/require.js" data-main="scripts/app"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>If we reload the page and try to enter another todo, it should work exactly like before. The only difference is that footwork is now loading the viewModels/components automatically for us.
        If we were to not include the <span class="inline-code">&lt;todoform&gt;</span> custom element then that component (and its dependencies) would not be downloaded (the same is also true for
        <span class="inline-code">viewModel</span> wrappers).</p>
    </div>
  </section>


  <a id="routing" class="section-anchor"></a>
  <section name="routing">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Routing</h1>
    </header>
    <div class="content">
      <div class="workspace-setup">
        <div class="title">
          View the code for this step:
          <a class="live-demo" href="http://todo-tutorial.footworkjs.com/routing" target="_blank">Live Demo</a>
          <a href="https://github.com/reflectiveSingleton/todo-tutorial/compare/amd...routing" class="diff" target="_blank"><span class="icon-git-compare"></span> diff</a>
        </div>
        <div class="content">
          <pre><code class="bash">git checkout -f routing</code></pre>
        </div>
      </div>

      <p>What SPA is complete without routing? In this step we will be adding a login page as well as routes which filter the todo list based on its state.</p>
      
      <p>Routing in a single page app is about managing the state of application. This can include the loading of different views, or triggering some other change
        based on the URL in the address bar. The router in footwork has many features, including the ability to nest routers as well as many differing
        route configurations. The example shown in this tutorial is relatively basic, for a full explanation on footworks routing capabilities take a look at the
        <a href="/api/routing" data-bind="$route">routing API documentation</a>.</p>

      <p>There are 3 principle components of routers in footwork which make useful:</p>

      <ul>
        <li><a data-bind="$route" href="/api/routing#configuration" data-bind="$route">configuration object</a>: A router configuration on a viewModel. Used to define
          the router, its routes, controllers, and their actions.</li>
        <li><a data-bind="$route" href="/api/routing#outlets" data-bind="$route">outlets</a>: Any number of
          <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declarations in your HTML which are the output points your router controls.</li>
        <li><a data-bind="$route" href="/api/routing#route-binding" data-bind="$route">route bindings</a>: Special bindings for links (and other tags) which will
          initiate new states in your application.</li>
      </ul>

      <p>The first thing we need to do when setting up a router in footwork, is deciding where it will 'live'. Routers in footwork are attached to viewModels,
        specified either in a standalone <span class="inline-code">&lt;viewModel&gt;</span> or on a <span class="inline-code">viewModel</span> which is part of a component.
        The reason for this is that the <span class="inline-code">outlet</span> and <span class="inline-code">$route</span> binding declarations are controlled by 
        (or attach themselves to) the nearest parent router found in the DOM.</p>

      <p>This parent-seeking nature allows for outlets and <span class="inline-code">$route</span> bindings which can be nested as deeply as you would like within
        other elements, viewModels, components, etc.</p>

      <p>For our todo application, we will only need one router. Since this router is to control the entirety of the application it makes sense to put it on an
        'outermost' viewModel so that anything we might want to control will be a decendant (or inside the scope of) the DOM for that router.</p>

      <p>Looking at our current code, we don't actually have a viewModel that encompasses the entire application, we currently have the
        <span class="inline-code">TodoForm</span> and the <span class="inline-code">TodoList</span> (as well as <span class="inline-code">TodoItem</span>) viewModels.
        Lets start by creating a container viewModel that we will wrap our entire application with which will simply house our router for us.</p>

      <h3>First, lets wrap our HTML with a new <span class="inline-code">&lt;viewModel&gt;</span> declaration:</h3>
<div class="file-location">/index.html</div>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;body&gt;
    &lt;viewModel module="Main"&gt; &lt;!-- new 'Main' viewModel wrapper which will have our router --&gt;
      &lt;main&gt;
        &lt;todoform&gt;&lt;/todoform&gt;
        &lt;viewModel module="TodoList"&gt;
          &lt;!-- ... --&gt;
        &lt;/viewModel&gt;
      &lt;/main&gt;
    &lt;/viewModel&gt;
    &lt;script src="bower_components/requirejs/require.js" data-main="scripts/app"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;!-- ... --&gt;</code></pre>

      <p>Now we need to prepare the <span class="inline-code">viewModel</span> which will house our router for us. A router is created when a viewModel is instantiated
        which has a router configuration object. Lets create our new <span class="inline-code">Main</span> viewModel with a basic router configuration so that
        when footwork processes the <span class="inline-code">&lt;viewModel&gt;</span> declaration our viewModel will be instantiated along with it.</p>

      <h3>Our <span class="inline-code">Main</span> viewModel with its basic router configuration object:</h3>
<div class="file-location">/scripts/viewModels/Main.js</div>
<pre><code class="javascript">define(['footwork'],
  function(fw) {
    return fw.viewModel({
      namespace: 'Main',
      router: {
        routes: [
          {
            route: '/', // default route
            title: 'Todo Application Tutorial',
            controller: function() {
              // do something here
            }
          }
        ]
      }
    });    
  }
);</code></pre>

      <div class="note"><span class="label">NOTE:</span> There are many available options for routers, the preceding definition keeps it simple for sake of the
        tutorial. If you want the in-depth overview of options available (and other things) for routers then take a look at the 
        <a href="/api/routing" data-bind="$route">router API documentation</a>.</div>

      <p>What we see above is a very basic <span class="inline-code">viewModel</span> definition which has a router configuration. The router configuration
        defines one route <span class="inline-code">'/'</span> (which is the default/base route). The controller will get triggered/called anytime this route is triggered.</p>

      <p>Now, we call <span class="inline-code">fw.viewModels.registerLocation()</span>
        just as we did in the preceeding step so that footwork knows where to find it when it encounters the <span class="inline-code">&lt;viewModel&gt;</span>
        declaration in our markup.</p>

<div class="file-location">/scripts/app.js</div>
<pre><code class="javascript">// ...
require([ 'footwork' ],
  function(fw) {
    fw.components.registerLocation('todoform', {
      viewModel: '/scripts/viewModels/TodoForm.js',
      template: '/scripts/templates/TodoForm.html'
    });

    /**
     * Tell footwork it can find both the 'Main' and 'TodoList' viewModels
     * inside of /scripts/viewModels.
     */
    fw.viewModels.registerLocation([
      'Main',
      'TodoList'
    ], '/scripts/viewModels/');

    // tell footwork to startup and begin binding
    fw.start(); 
  }
);</code></pre>
   

    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "TodoMVC Tutorial",
  "description": "",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction" },
    { "anchor": "getting-started",
      "title": "Getting Started",
      "subSections": [
        { "anchor": "prerequisites",
          "title": "Prerequisites" }
      ] },
    { "anchor": "setup",
      "title": "Setup" },
    { "anchor": "base-app",
      "title": "Base Application",
      "subSections": [
        { "anchor": "creating-the-app",
          "title": "Creating the App" },
        { "anchor": "creating-todos",
          "title": "Creating Todos" }
      ] },
    { "anchor": "components",
      "title": "Components" },
    { "anchor": "amd-requirejs",
      "title": "AMD / RequireJS" },
    { "anchor": "routing",
      "title": "Routing" }
  ]
}
</div>