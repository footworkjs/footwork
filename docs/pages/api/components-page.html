<article>
  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>A component can be thought of as a viewModel + template combination composed together and inserted into the DOM for you.</p>
      <p>footwork.js extends the components feature found in <a href="http://knockoutjs.com" target="_blank">knockout.js</a> 3.2+ to enable many additional features, some of which being:</p>
      <ul>
        <li>Full template and viewModel encapsulation.</li>
        <li>Extremely easy to use (and re-use!) expressive and semantic <span class="inline-code">&lt;custom-elements&gt;&lt;/custom-elements&gt;</span></li>
        <li>Unlimited nesting capability (you can also nest footwork <a href="/api/viewModel" data-bind="$route">viewModels</a>).</li>
        <li>Fully cachable components.</li>
        <li>
          <p>Automatic component resolution via AMD/RequireJS based on the component/module name in the markup.</p>
          <p class="top">You can also use the standard knockout <a href="http://knockoutjs.com/documentation/component-binding.html" target="_blank">component binding</a> to initialize your components.</p>
        </li>
        <li>Automatic viewModel initialization and binding.</li>
        <li>Lifecycle events.</li>
        <li>Routing integration (easily manage components and state, see: <a href="/api/routing" data-bind="$route">routing</a>)</li>
        <li><span class="inline-code">fw.viewModel()</span> integration (see: <a href="/api/viewModel" data-bind="$route">viewModel</a>).</li>
      </ul>
      <p>Another great thing about footwork is that it fully supports any knockout.js component (<em>including markup/bindings</em>)...this means that you don't need to do any refactoring if you already have components you've written. You can 
      organically add the additional features from footwork as you see fit.</p>
      <p><em>In short, components are an extremely powerful feature which when leveraged properly allow you to build extremely modularized, easy to maintain, easy to test, and easy to read software.</em></p>
      <div class="note"><span class="label">NOTE:</span> Footwork uses knockout components as the base implementation, for further documentation concerning components please see the <a href="http://knockoutjs.com/documentation/component-overview.html" target="_blank">KnockoutJS component documentation</a>.</div>
    </div>
  </section>

  <a id="configuration" class="section-anchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>There are principally 2 pieces that need to be setup prior to a component being usable:</p>
      <ul>
        <li>The template/HTML/DOM to bind against the viewModel.</li>
        <li>The viewModel which the template/HTML/DOM is bound to.</li>
      </ul>
      <p>They are both essential. Inside of the template is the markup which comprises your component. The viewModel is the object your template is bound
      against (footwork can use <a href="http://knockoutjs.com/documentation/observables.html#mvvm-and-view-models" target="_blank">knockout viewModels</a> which can be created many
      ways, but <a href="/api/viewModel" data-bind="$route">footwork viewModels</a> are extra awesome).</p>
      <p>In addition to being autoloaded via RequireJS/AMD (if needed/possible), the viewModel will be initialized (if required) and bound to your template.</p>
      <p>Once both have been combined, the resulting composition is inserted into the DOM and then the <span class="inline-code">afterBinding()</span> lifecycle event is triggered on the viewModel.</p>
      <h3>A simple example of a template used in a component:</h3>
<pre><code data-language="html">&lt;!-- /components/templates/sprocket.html --&gt;
&lt;!-- Normal markup, including any bindings you want bound against the viewModel --&gt;
&lt;div class="info"&gt;
  &lt;div&gt;Sprocket&lt;/div&gt;
  Type: &lt;span data-bind="text: type"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="description" data-bind="text: description"&gt;&lt;/div&gt;</code></pre>
    </div>
  </section>

  <a id="usage" class="section-anchor"></a>
  <section name="usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Usage</h2>
    </header>
    <div class="content">
      <p>Using a component begins with inserting a custom element into your DOM/HTML (or using the standard knockout <a href="http://knockoutjs.com/documentation/component-binding.html" target="_blank">component binding</a>).</p>
      <div class="note">
        <p><span class="label">NOTE:</span> This is very similar to the <span class="inline-code">&lt;viewModel module=""&gt;&lt;/viewModel&gt;</span> declarative syntax used for viewModel instantiation. The difference being
        that instead of wrapping a section of HTML with a viewModel, they are paired together and composed prior to insertion into the DOM.
        See: <a href="/api/viewModel" data-bind="$route">viewModels</a>.</p>
      </div>
      <h3>For example, in <span class="inline-code">index.html</span> lets say we have have:</h3>
<pre><code data-language="html">&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;Look at this awesome Sprocket:&lt;/div&gt;

    &lt;!-- notice the custom element name, footwork uses this to lookup your component --&gt;
    &lt;sprocket&gt;&lt;/sprocket&gt;
    &lt;!-- NOTE: only lowercase alpha-numeric, and dash (-) characters are allowed for custom elements --&gt;

    &lt;!-- this also loads the same 'sprocket' component using the standard knockout binding --&gt;
    &lt;div data-bind="component: 'sprocket'"&gt;&lt;/div&gt;

    &lt;script src="/application.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <div class="note">
        <span class="label">NOTE:</span> You can nest both &lt;component&gt; and &lt;viewModel&gt; declarations within one another, footwork will pull in resources and wire it all up as needed.
      </div>
      <p>Once footwork encounters an element it doesn't recognize as being normal HTML it will do a lookup for the name and attempt to find the viewModel/template duo.</p>
    </div>
  </section>

  <a id="loading-registering" class="section-anchor"></a>
  <section name="loading-registering">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">AMD / Lazy Loading / Registering</h2>
    </header>
    <div class="content">
      <p>There are 3 ways footwork will try to resolve both the viewModel and template for your component once it encounters the 
      <span class="inline-code">&lt;component-name&gt;&lt;/component-name&gt;</span> or <span class="inline-code">&lt;span data-bind="component: 'component-name'"&gt;&lt;/span&gt;</span> markup.</p>
      <p>They are as follows (in order of priority):</p>
      <ul>
        <li>Pre-cached via a <span class="inline-code">fw.components.register()</span> call.</li>
        <li>Automatic download/resolution via AMD/RequireJS at a pre-registered location (<span class="inline-code">fw.components.registerLocation()</span>).</li>
        <li>Automatic download/resolution via AMD/RequireJS at the configurable default (<span class="inline-code">fw.components.defaultLocation()</span>).</li>
      </ul>

      <h3><em class="func-def">fw.components.register<span>( <span class="param">'name'</span>, <span class="param">optionsObject</span> )</span></em></h3>
      <h3>Register (cache) a component under a specified 'name' for later use:</h3>
<pre><code data-language="javascript">// Using a footwork viewModel
fw.components.register('sprocket', {
  viewModel: fw.viewModel({ /* ... configuration object ... */ }),
  template: '&lt;div data-bind="text: textProperty"&gt;&lt;/div&gt;'
});

// Using a regular constructor function
fw.components.register('sprocket', {
  viewModel: function() { this.textProperty = 'hello world'; },
  template: '&lt;div data-bind="text: textProperty"&gt;&lt;/div&gt;'
});</code></pre>
      <div class="note">
        <span class="label">NOTE:</span>
        <ul>
          <li>Footwork fully supports regular knockout component registration (<span class="inline-code">ko.components.register()</span>, 
          see <a href="http://knockoutjs.com/documentation/component-registration.html">the documentation</a>)</li>
          
          <li>Registering components is not necessary if you have RequireJS and tell footwork where it can download them (see 
          <span class="inline-code">fw.components.registerLocation()</span> and <span class="inline-code">fw.components.defaultLocation()</span> down below).</li>
          
          <li>It is recommended you load these assets (the viewModel and template) in via some other means. Footwork preferences loading them with
          <a href="http://requirejs.org">AMD/RequireJS</a> because of its inherent async capabilities/runtime dependency resolution/etc, however if <a href="http://browserify.org" target="_blank">Browserify</a> is more your taste that will work just as well.</li>
        </ul>
      </div>

      <h3>Tell footwork how to use AMD/RequireJS to automatically resolve/download your component</h3>
      <p>It is also possible to simply tell footwork where your assets are and let it take care of downloading and initializing them for you. The folliwing methods (<span class="inline-code">fw.components.registerLocation()</span> <span class="inline-code">fw.components.defaultLocation()</span>) outline how to do that.</p>

      <h3><em class="func-def">fw.components.registerLocation<span>( <span class="param">'name'</span>, <span class="param">{ viewModel: 'path/to/viewModel', template: 'path/to/template' }</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">fw.components.registerLocation<span>( <span class="param">'name'</span>, <span class="param">{ combined: 'path/to/combinedComponentFile' }</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">fw.components.registerLocation<span>( <span class="param">'name'</span>, <span class="param">'path/to/combinedComponentFile'</span> )</span></em></h3>
      <h3>Tell footwork where to find the component 'name' using the supplied configuration:</h3>
<pre><code data-language="javascript">/**
 * Register component under 'sprocket' using individual paths for the viewModel and template files.
 * The file name will be appended using the name of the component + .ext
 */
fw.components.registerLocation('sprocket', {
  viewModel: '/viewModels/bikeParts', // load from /viewModels/bikeParts/sprocket.js
  template: '/templates/bikeParts' // load from /templates/bikeParts/sprocket.html
});

// Specify the full file name (ie: use this if the file name does not conform to what footwork expects)
fw.components.registerLocation('sprocket', {
  viewModel: '/viewModels/bikeParts/TheSprocket.js', // load from /viewModels/bikeParts/TheSprocket.js
  template: '/templates/bikeParts/theSprocket.html' // load from /templates/bikeParts/theSprocket.html
});

// Specify the 'combined' module to be downloaded (see the 'Module formats' section on this page)
fw.components.registerLocation('sprocket', '/components'); // load from /components/sprocket.js
fw.components.registerLocation('sprocket', '/components/theSprocket.js'); // load from /components/theSprocket.js

// You can also specify the path to many components at once (footwork will append the appropriate file name):
fw.components.registerLocation(['sprocket', 'wheel'], {
  viewModel: '/viewModels/bikeParts',
  template: '/templates/bikeParts'
});
fw.components.registerLocation(['sprocket', 'wheel'], '/components');
</code></pre>

      <h3><em class="func-def">fw.components.defaultLocation<span>( <span class="param">{ viewModel: 'path/to/viewModels', template: 'path/to/templates' }</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">fw.components.defaultLocation<span>( <span class="param">{ combined: 'path/to/combinedComponentFiles' }</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">fw.components.defaultLocation<span>( <span class="param">'path/to/combinedComponentFiles'</span> )</span></em></h3>
      <h3>Tell footwork where to look for a component if it isn't registered explicitly (ie: when all else fails):</h3>
<pre><code data-language="javascript">// Load components using individual paths for the viewModel and template files.
fw.components.defaultLocation({
  viewModel: '/viewModels', // load from /viewModels/[component-name].js
  template: '/templates' // load from /templates/[component-name].html
});

// Load components in combined format by default from /components/[component-name].js
fw.components.defaultLocation('/components');
</code></pre>
    </div>
  </section>

  <a id="module-formats" class="section-anchor"></a>
  <section name="module-formats">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Module Formats</h1>
    </header>
    <div class="content">
      <p>Footwork templates are always loaded as plain HTML files (plain text), but viewModels are loaded as javascript modules. viewModels can either be expressed inline (ie: when registering a
      component explicitly), or resolved via a script loader.</p>
      <p>Both <a href="http://requirejs.org">AMD/RequireJS</a> and <a href="http://browserify.org" target="_blank">Browserify</a> are supported. RequireJS is preferred as it will enable
      footwork to resolve your viewModels/components (and their dependencies) automatically at runtime as needed.</p>
      <p>The following examples all show the RequireJS/AMD flavored versions.</p>
      <h3>viewModel and template are loaded separately:</h3>
<pre><code data-language="javascript">// File located in: /viewModel/sprocket.js
define(["footwork"],
  function(fw) {
    return fw.viewModel({
      namespace: 'sprocket'
      // ...
    });
  }
);</code></pre>
<pre><code data-language="html">&lt;!-- File located in: /template/sprocket.html --&gt;
&lt;div class="info"&gt;
  &lt;div&gt;Sprocket&lt;/div&gt;
  Type: &lt;span data-bind="text: type"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="description" data-bind="text: description"&gt;&lt;/div&gt;</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> You can return any constructor function or plain object from your viewModel modules (you don't have to return a footwork viewModel constructor as shown).</p>
      </div>

      <h3><em class="func-def">fw.component<span>( <span class="param">{ viewModel: [viewModel], template: '&lt;!-- template HTML --&gt;' }</span> )</span></em></h3>
      <h3>viewModel and template are loaded as a combined viewModel + template module:</h3>
<pre><code data-language="javascript">// File located in: /components/sprocket.js
define(["footwork"],
  function(fw) {
    return fw.component({
      viewModel: fw.viewModel({
        namespace: 'sprocket'
        // ...
      }),
      template: '&lt;div&gt;&lt;-- template HTML --&gt;&lt;/div&gt;'
    });
  }
);</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> You can use any constructor function or plain object as the viewModel for your component modules (you don't have to use a footwork viewModel constructor as shown).</p>
      </div>
    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "Components",
  "description": "Re-usable modular components.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction",
      "subSections": [
        { "anchor": "configuration",
          "title": "Configuration" },
        { "anchor": "usage",
          "title": "Usage" },
        { "anchor": "loading-registering",
          "title": "AMD / Lazy Loading / Registering" },
        { "anchor": "module-formats",
          "title": "Module Formats" }
      ] }
  ]
}
</div>