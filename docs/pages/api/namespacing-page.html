<article>
  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>Namespaces in footwork can be thought of as communication 'channels'. They are the information highways your application uses to shuffle data and state from one area to another.</p>
      <p>Organizing your modules and keeping them decoupled is extremely important in more complex javascript applications. Without a standardized way of coordinating information, an application
      will quickly turn into to a horrible tangled mess of code. This tangled mess becomes a buggy unmanageable piece of poo...no one likes to touch poo.</p>
      <p>Footwork marshals all of that by organizing your modules firstly by namespaces. Namespaces boil down to a simple <span class="inline-code">'string'</span> value which is used to segment off
      the communication meant for one module from another. Footwork uses this namespacing to provide a lot of enhanced functionality via 
      <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" title="Command Query Responsibility Segregation">CQRS</a> and other common communications design patterns.</p>
      <h3>All of this essentially means is that the communication between your modules/viewModels/components/<em>whatever</em> will be both expressive and easily managed.</h3>
      <div class="note"><span class="label">NOTE:</span> At its core namespaces in footwork are enhanced <a href="https://github.com/postaljs/postal.js" target="_blank">postal.js</a> pub/sub channels.
      If you need to enhance or alter how communication is handled then you likely want to take a look at the postal documentation.</div>
    </div>
  </section>

  <a id="usage" class="section-anchor"></a>
  <section name="usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Usage</h2>
    </header>
    <div class="content">
      <p>There are essentially 2 different ways a namespace can be used:</p>
      <ul>
        <li>In tandem with a viewModel/component, automatically initialized and disposed of for you.</li>
        <li>Independently/Manually instantiated by you and <em>sometimes</em> disposed of for you.</li>
      </ul>
      <div class="note"><span class="label">NOTE:</span> If you just need to share a property across viewModels/components then take a look <a href="/api/broadcastable-receivable" data-bind="$route">broadcastable / receivable</a>, they make
      basic sharing of data between modules a no-brainer.</div>
    </div>
  </section>

  <a id="independent-usage" class="section-anchor"></a>
  <section name="independent-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Independent Usage</h2>
    </header>
    <div class="content">
      <p>You will need to instantiate a namespace channel anytime you need to send a command/request, trigger an event, or publish some piece of information to another namespace.</p>
      <p>To do this, call the <span class="inline-code">fw.namespace()</span> factory and pass it a string (namespace name).</p>
      <h3><em class="func-def">fw.namespace<span>( <span class="param">'namespaceName'</span> )</span></em></h3>
<pre><code class="javascript">var myNamespace = fw.namespace('myNamespace');
myNamespace.subscribe('hello', function(fromWhom) {
  console.info('Greetings ' + fromWhom);
});

myNamespace.publish('hello', 'Jonathan'); // console prints: 'Greetings Jonathan'
</code></pre>
      <p>It is important to note that namespaces are based on their <span class="inline-code">'string'</span> key, not the instantiated object...those are just the channels <em>to</em> that namespace.</p>
      <h3>This means that each newly instantiated namespace with the same <span class="inline-code">'string'</span> key will all hear the same events/commands/etc:</h3>
<pre><code class="javascript">var myNamespace = fw.namespace('myNamespace');
myNamespace.subscribe('hello', function(fromWhom) {
  console.log('Greetings ' + fromWhom);
});

var alsoMyNamespace = fw.namespace('myNamespace');
alsoMyNamespace.publish('hello', 'Jonathan'); // console prints: 'Greetings Jonathan'
</code></pre>
    </div>
  </section>

  <a id="tandem-usage" class="section-anchor"></a>
  <section name="tandem-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Tandem Usage (with viewModel/component)</h2>
    </header>
    <div class="content">
      <p>Anytime you place a <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> or <span class="inline-code">&lt;component&gt;&lt;/component&gt;</span> in your markup footwork is
      essentially wrapping that section of HTML with a viewModel. That viewModel has a namespace attached to/associated with it (based on the <span class="inline-code">namespace:</span> viewModel configuration attribute, see <a href="/api/viewModel" data-bind="$route">viewModel</a>).</p>
      <p>When footwork sets up the new instance of your viewModel it automatically creates a namespace channel and assigns it to <span class="inline-code">this.$namespace</span>. This namespace will have its lifecycle handled automatically, and any subscriptions made on it will be cleaned up when the viewModel is destroyed.</p>
<pre><code>&lt;!-- File: index.html --&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Sprocket"&gt;
      &lt;!-- ko if: isExpensive --&gt;
        &lt;!--
          namespace and all handlers for warning-component viewModel
          handled automatically whenever it is added or removed from the DOM
        --&gt;
        &lt;warning-component&gt;&lt;/warning-component&gt;
      &lt;!-- /ko --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<pre><code class="javascript">// File: /components/viewModel/warning-component.js
define(["footwork"],
  function( fw ) {
    return fw.viewModel({
      namespace: 'Warning',
      initialize: function() {
        this.message = fw.observable('This Sprocket is expensive!');

        this.$namespace.subscribe('clearWarning', function() {
          // this handler will be automatically unsubscribed and cleaned up
        });
      }
    });
  }
);
</code></pre>
      <div class="note"><span class="label">NOTE:</span> Lifecycle events (<span class="inline-code">afterBinding()</span> and <span class="inline-code">onDispose()</span>) are also dispatched whenever a viewModel or component-viewModel are added/removed from the DOM. See <a href="/api/viewModel" data-bind="$route">viewModel</a>.</div>

    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "Namespacing",
  "description": "Namespacing, the communication channels of your application.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction" },
    { "anchor": "usage",
      "title": "Usage",
      "subSections": [
        { "anchor": "independent-usage",
          "title": "Independent Usage" },
        { "anchor": "tandem-usage",
          "title": "Tandem Usage" }
      ] }
  ]
}
</div>