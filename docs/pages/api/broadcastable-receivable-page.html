<article>

  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content block-font">
      <p>The broadcastable and receivable functionality provides for an easy method of inter-module/namespace property sharing, communication, and computed
      values. What this essentially means is that a variable in one viewModel/module can update the value in another and be kept in sync automatically. By taking advantage of this functionality
      your application is able to expressively share state and data while being kept as loosely coupled as possible.</p>
      <p>Broadcastables and receivables are extended/special knockout observables which hook into the namespacing provided by footwork to either send data (broadcastable) or receive data (receivable) to or from other namespaces/modules.</p>
      <div class="note"><span class="label">NOTE:</span> Broadcastables and receivables are integrated with (and make most sense when used with) <a href="/api/viewModel" data-bind="$route">footwork viewModels</a> but you can also use them independently.</div>
    </div>
  </section>

  <a id="usage" class="section-anchor"></a>
  <section name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Usage</h1>
    </header>
    <div class="content block-font">
      <p>Broadcastables are created by taking an observable and calling <span class="inline-code">observable.broadcastAs()</span> on it, receivables are created by taking an observable and calling <span class="inline-code">observable.receivFrom()</span> on it. Broadcastables and receivables can be based off of any knockout observable type (observable, computed observable, observableArray).</p>
      <div class="note"><span class="label">NOTE:</span> Receivables must be 'writable' (when receiving data from a broadcastable, the observable it is based off of must be able to be written to). This means that if you have a computed receivable, it must have a <span class="inline-code">write:</span> method specified.</div>
      <p>Receivables are listeners for information that a broadcastable sends out. Anytime a <span class="inline-code">broadcastable</span> send out an updated value for the variable a <span class="inline-code">receivable</span> is configured for, the receivable will be updated, its listeners notified, and propagate through any computed values as expected.</p>
      <p>The module a broadcastable is attached to should be thought of as the 'owner' of that property, and any related logic should (ideally) also be contained within that module/lexical scope.</p>
      <p>Since receivables and broadcastables are just extended observables, any computed properties based off of them will propagate just like normal knockout observables.</p>
      <div class="note"><span class="label">NOTE:</span> Because of their reliance on the message bus, broadcastables and receivables must be cleaned up when disposing of them. Any broadcastable or receivable which is assigned to a viewModel will automatically be cleaned up along with that viewModel. If you are using them independently, you will need to call <span class="inline-code">observable.dispose()</span> when you intend to get rid of it.</div>
    </div>
  </section>

  <a id="observable-receiveFrom" class="section-anchor"></a>
  <section name="observable-receiveFrom">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">observable.receiveFrom<span>( <span class="param">'namespaceName'</span>, <span class="param">'variableName'</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">observable.receiveFrom<span>( <span class="param">namespace</span>, <span class="param">'variableName'</span> )</span></em></h3>
      <h3 class="top">Examples:</h3>
<pre><code class="javascript">var Navigation = fw.viewModel({
  namespace: 'Navigation',
  initialize: function() {
    // initial value provided to the observable is the default, before any data is received from a broadcastable
    this.userIsLoggedIn = fw.observable(null).receiveFrom('User', 'isLoggedIn'); // value is null
    this.loggedInUsername = fw.observable().receiveFrom('User', 'username'); // value is undefined

    // This computed is based off of the two previous receivables
    this.navGreeting = fw.computed(function() {
      if(this.userIsLoggedIn()) {
        return 'Welcome ' + this.loggedInUsername();
      } else {
        return 'Please login';
      }
    }, this);
  }
});

/**
 * Note: See the next section for details on broadcastables
 */
var User = fw.viewModel({
  namespace: 'User',
  initialize: function() {
    this.loggedIn = fw.observable(false).broadcastAs('isLoggedIn');
    this.username = fw.observable().broadcastAs('username');
    this.login = function(user, pass) {
      if(user === 'DarkHelmet' && pass === '12345') {
        this.username(user);
        this.loggedIn(true);
      }
    };
  }
});

var navigation = new Navigation();
// navigation.userIsLoggedIn() === null
// navigation.navGreeting() === 'Please login'

var user = new User();
// user.loggedIn() === false
// navigation.userIsLoggedIn() === false

user.login('DarkHelmet', '12345');
// user.username() === 'DarkHelmet'
// navigation.userIsLoggedIn() === true
// navigation.navGreeting() === 'Welcome DarkHelmet'
</code></pre>
      <div class="note"><span class="label">NOTE: </span> If you directly reference a namespace object when creating a broadcastable or receivable it will be disposed of when the namespace is disposed of (meaning it will no longer broadcast or receive updates to its value).</div>
    </div>
  </section>

  <a id="observable-broadcastAs" class="section-anchor"></a>
  <section name="observable-broadcastAs">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">observable.broadcastAs<span>( <span class="param">'variableName'</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">observable.broadcastAs<span>( <span class="param">'variableName'</span>, <span class="param">isWritable</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">observable.broadcastAs<span>( <span class="param">{ name: 'variableName', writable: isWritable }</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">observable.broadcastAs<span>( <span class="param">{ name: 'variableName', namespace: Namespace, writable: isWritable }</span> )</span></em></h3>
      <h3 class="top"><em class="func-def">observable.broadcastAs<span>( <span class="param">{ name: 'variableName', namespace: 'NamespaceName', writable: isWritable }</span> )</span></em></h3>
      <p>Broadcastable values can be either read-only or writable. A writable broadcastable will allow a receivable to
          write back its value upstream. This means you can have a value broadcast from one namespace/module and allow a receivable to both listen for and update its value (with that value propogating back to the broadcaster).</p>
      <div class="note"><p><span class="label">NOTE:</span> Although broadcastables can be writable, try to avoid writing to them from external modules. The broadcastable should ideally have associated 
        logic contained within the module it is attached to. 'Reaching in' from an external location breaks the concept of separation of concerns and can lead to spaghettification of your code.</p>
      </div>
      <h3 class="top">Read-only Examples:</h3>
<pre><code class="javascript">var User = fw.viewModel({
  namespace: 'User',
  initialize: function(username) {
    // broadcastAs() will use the namespace of the viewModel by default.
    this.username = fw.observable(username).broadcastAs('username');
  }
});

// You can also be explicit or broadcast on a different namespace
var appUsername = fw.observable(username).broadcastAs({ name: 'username', namespace: 'Application' });
// Note: Try to keep broadcastables located within their respective module
//       (ie: try not to broadcast to a different namespace than the current one, this is mostly
//            for use outside of a viewModel context)

// receivable listening for updates on 'username' from the 'User' namespace
var userName = fw.observable(null).receiveFrom('User', 'username');
// userName() === null

// create user object that broadcasts 'username'
var user = new User('Jonathan');
// ...and now the receivable is updated by the broadcastable:
// userName() === 'Jonathan'

/**
 * Note that 
 */

// Outside of a viewModel, specifying the namespace name
var username = fw.observable().broadcastAs({ name: 'username', namespace: 'User' });

// Outsite of a viewModel, specifying the namespace
var userNamespace = fw.namespace('User');
var username = fw.observable().broadcastAs({ name: 'username', namespace: userNamespace });
</code></pre>
      <div class="note"><span class="label">NOTE:</span> It does not matter if the broadcastable or receivable is created first:
        <ul>
          <li>As soon as the broadcastable is instantiated any receivables listening will be updated.</li>
          <li>As soon as a receivable is instantiated it will request the current value (if there is one) from the broadcastable.</li>
        </ul>
      </div>

      <h3>Writable example:</h3>
<pre><code class="javascript">var User = fw.viewModel({
  namespace: 'User',
  initialize: function() {
    // Writable broadcastable, can be written to by a receivable
    this.browserType = fw.observable('unknown').broadcastAs('browserType', true);
    this.browserType.subscribe(function(browserType) {
      // a normal subscription to updates on the observable this.browserType
      if(browserType === 'Internet Explorer 6') {
        console.log('I am sorry, we do not support ancient technologies.');
      }
    });
  }
});
var user = new User(); // create a user using the viewModel declaration from above
// user.browserType() === 'unknown'

var userBrowserType = fw.observable(null).receiveFrom('User', 'browserType');
/**
 *
 * userBrowserType() === 'unknown'
 *
 * Then when you make an update, it will try to write that back to the broadcastable, if that
 * broadcastable is writable it will be listening for any updates and act accordingly, updating
 * its own value, informing any listeners, and propogating through any computed values.
 */
userBrowserType('Internet Explorer 6');
// console will print: 'I am sorry, we do not support ancient technologies.'

</code></pre>
    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "Broadcastable / Receivable",
  "description": "Inter-module communication and computed values.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction" },
    { "anchor": "usage",
      "title": "Usage",
      "subSections": [
        { "anchor": "observable-receiveFrom",
          "title": "observable.receiveFrom()" },
        { "anchor": "observable-broadcastAs",
          "title": "observable.broadcastAs()" }
      ] }
  ]
}
</div>