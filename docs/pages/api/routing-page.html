<article>

  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Introduction</h1>
    </header>
    <div class="content">
      <p>Routing in a web application is about managing state. Modern single-page web applications make use of the HTML5 <span class="inline-code">history</span>
      API in order to retain normal browser navigation while not forcing a complete refresh of the page on every state/url change. Footwork includes a router which
      provides this functionality.</p>
      <p>The router included with footwork has a few key features:</p>
      <ul>
        <li>Unlimited nesting of routers (relative and non-relative).</li>
        <li>Unlimited number of view outlets per router.</li>
        <li>Context based sub-routing.</li>
        <li>Context based outlets.</li>
        <li>Parameterized routes (with optional or required parameters).</li>
        <li>Filtered/predicated routes.</li>
        <li>Integration with <a href="https://github.com/browserstate/history.js/" target="_blank">history.js</a> for cross-browser history API support.</li>
      </ul>
      <p>In essence the router combines several design patterns (MVC + MVVM + Observable), context-based subrouting, and context-based outlets to provide a novel and extremely powerful routing solution.</p>
    </div>
  </section>

  <a id="usage" class="section-anchor"></a>
  <section name="usage">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Usage</h1>
    </header>
    <div class="content">
      <p>Routers have three principle components which make them useful:</p>
      
      <ul>
        <li><a data-bind="$route" href="#configuration" data-bind="$route">configuration object</a>: A router configuration on a viewModel. Used to define the router, its routes, controllers, and their actions.</li>
        <li><a data-bind="$route" href="#outlets" data-bind="$route">outlets</a>: Any number of <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declarations in your HTML which are the output points your router controls.</li>
        <li><a data-bind="$route" href="#route-binding" data-bind="$route">route bindings</a>: Special bindings for links (and other tags) which will initiate new states in your application.</li>
      </ul>
      
      <p>Just as a viewModel 'wraps' a section of your HTML providing the binding points and logic for that portion of your application. In a similar sense,
      a router also 'wraps' and provides all routing logic for that portion of your application. Anywhere there is an 
      <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declaration, footwork will traverse up the DOM searching for the nearest parent
      viewModel which has a router. That router is able to control what view/component
      is displayed in any <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declarations found within its scope.</p>
      
      <p>This same parent-seeking logic holds true for both route bindings and nested routers (configured with <span class="inline-code">isRelative: true</span>) as well. Routers will iteratively
      walk the DOM upwards searching for (and making their routes relative to) the nearest parent router (if one is found). Route bindings do the same
      and will then trigger state changes on that router as appropriate.</p>
      
      <p>It is by this parent-seeking nature that it is possible to nest routers, outlets, and route bindings in any configuration and at any depth and complexity.</p>
    </div>
  </section>

  <a id="configuration" class="section-anchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Configuration</h1>
    </header>
    <div class="content">
      <p>Routers are incorporated into <a href="/api/viewModel" data-bind="$route">footwork viewModels</a>, to create one you must add a router <a href="/api/viewModel#configuration" data-bind="$route">configuration to a viewModel</a>.</p>
      <h3>A synopsis of router configuration options:</h3>
<pre><code class="javascript">var ViewModel = fw.viewModel({
  // ...
  router: {
    // if true all routes defined for the router will be relative to its parent router (if any)
    isRelative: true, // default is true

    // routes list definition
    routes: [],

    // unknown route (triggered if none of the routes[] match from above)
    unknownRoute: {},

    // if true the router will activate as soon as its viewModel is bound to the DOM
    activate: true, // default is true

    // tell the router to exclude the beginning portion of a route
    baseRoute: '', // default is null

    // by default the namespace is based off of the viewModel it is paired with
    namespace: 'namespaceName', // (this is not usually needed)
  },
  // ..
});</code></pre>
      
      <div class="note"><span class="label">NOTE:</span> The router is instantiated (and disposed of) along with the viewModel and is available at <span class="inline-code">viewModel.$router</span> after instantiation.
      Once the viewModel is bound to the DOM (either because it is part of a component, viewModel, or is manually bound) the router will activate and the current route (url) will be expressed.</div>
      
      <p>The <span class="inline-code">routes: []</span> and <span class="inline-code">unknownRoute: {}</span> definitions both have the same syntax. The only difference between
      these two is that <span class="inline-code">routes: []</span> is an array of route definitions, and <span class="inline-code">unknownRoute: {}</span> is a single route definition.
      These define the routes your application (on this router) has available to it.</p>

      <ul>
        <li><a data-bind="$route" href="#routes" data-bind="$route">Routes List</a></li>
        <li><a data-bind="$route" href="#route" data-bind="$route">Route Definition</a></li>
        <li><a data-bind="$route" href="#router-properties" data-bind="$route">Router Properties</a></li>
      </ul>
    </div>
  </section>

  <a id="routes" class="section-anchor"></a>
  <section name="routes">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Routes List</h2>
    </header>
    <div class="content">
      <p>When a new state/url is requested each router will iteratively search its <span class="inline-code">routes: []</span> list from the top down for the first matching route. If more than one 
      route matches for a given url/state then only the first one found found will be used.</p>
      
      <h3>Example <span class="inline-code">routes: []</span> list definition:</h3>
<pre><code class="javascript">// ...
routes: [
  { // default route: '/'
    route: '/',
    // ...
  },
  { // route: /store
    route: '/store',
    // ...
  }
],
unknownRoute: { /* ... */ }
// ...
</code></pre>
      <div class="note"><span class="label">NOTE:</span> The <span class="inline-code">unknownRoute:</span> definition has no <span class="inline-code">route:</span> parameter (it is ignored if included). This route
      is triggered when no matching route is found in the <span class="inline-code">routes:</span> list. It is otherwise configured just like the other route definitions.</div>
    </div>
  </section>

  <a id="route" class="section-anchor"></a>
  <section name="route">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Route Definition</h2>
    </header>
    <div class="content">
      <p>A route definition is simply an object which describes a route. Footwork will match the browser path up
      against the <span class="inline-code">route:</span> parameter and use the other options to trigger and setup the state of your application.</p>
      
      <p>A route definition has four possible parameters:</p>
      <ul>
        <li><span class="inline-code">route:</span> - A specially structured string which is used to match against a given URL (and optionally provide for named parameters).</li>
        <li><span class="inline-code">controller:</span> - Callback function used when a route is chosen, this is where <span class="inline-code">outlets</span> get changed and the state of your application is altered. Any parameters defined by the <span class="inline-code">route:</span> will be passed in.</li>
        <li><span class="inline-code">title:</span> - (<em>optional</em>) A string or callback function used to set the title of the page when the route is chosen. Any parameters defined by the <span class="inline-code">route:</span> will be passed in.</li>
        <li><span class="inline-code">filter:</span> - (<em>optional</em>) A predicate function used to tell footwork if it should consider a route. Any parameters defined by the <span class="inline-code">route:</span> will be passed in.</li>
      </ul>
      
      <h3><span class="inline-code">route:</span> example definitions with and without parameters specified:</h3>
      <h3><span class="inline-code">controller:</span> example definitions with and without parameters passed in:</h3>
<pre><code class="javascript">// ...
routes: [
  { // static route (no parameters): /about-us
    route: '/about-us',
    controller: function() { /* ... */ }
  },
  { // route with required parameter isbn
    route: '/book/:isbn',
    controller: function(params) {
      console.log('Book ISBN', params.isbn);
    }
  },
  { // route with optional parameter storeNum
    route: '/info(/:storeNum)',
    controller: function(params) {
      // params.storeNum is undefined if no storeNum is provided in the route
      console.log('Store Number', params.storeNum);
    }
  }
],
// ...
</code></pre>

      <h3><span class="inline-code">title:</span> example definitions as a string and callback:</h3>
      <p>This (optional) parameter defines what the title of the page will be set to when routing to this route. The route params (if any) as described by the route: string will be passed in.</p>
<pre><code class="javascript">// ...
routes: [
  { // 'string' title
    title: 'Store Page',
    route: '/store',
    controller: function() { /* ... */ }
  },
  { // callback-based title
    title: function(params) {
      return 'Book ' + params.isbn;
    },
    route: '/book/:isbn',
    controller: function(params) { /* ... */ }
  }
],
// ...
</code></pre>
      
      <h3><span class="inline-code">filter:</span> example definition:</h3>
      <p>If this (optional) callback returns a 'falsey' value, the
      router will ignore the route even if the path matches. Conversely if the callback returns a
      'truthy' value the router will consider it on a first-found first-routed basis as normal.
      The route params (if any) as described by the <span class="inline-code">route:</span> string will be passed in.</p>
<pre><code class="javascript">// ...
routes: [
  { // only routed to when isbn === '12345'
    route: '/book/:isbn',
    title: 'Special Book Page',
    controller: function(params) {
      console.log('Special Book ISBN', params.isbn);
    },
    filter: function(params) {
      if(params.isbn === '12345') {
        return true; // this route used only if isbn === '12345'
      }
      return false;
    }
  },
  { // normal book/:isbn route that is used when isbn !== '12345'
    route: '/book/:isbn',
    title: 'Home Page',
    controller: function(params) {
      console.log('Book ISBN', params.isbn);
    }
  }
],
// ...
</code></pre>
      <div class="note"><span class="label">NOTE:</span> Remember that you can always <a href="/api/namespacing#request" data-bind="$route"><span class="inline-code">request</span></a>
      data, or use <a href="/api/broadcastable-receivable" data-bind="$route"><span class="inline-code">receivables</span>/<span class="inline-code">broadcastables</span></a>/etc inside of your filter functions too.</div>
    </div>
  </section>

  <a id="router-properties" class="section-anchor"></a>
  <section name="router-properties">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">(instantiated) Router Properties</h2>
    </header>
    <div class="content">
      <p>After a router has been instantiated (it is available immediately after a viewModel instance is created, at <span class="inline-code">viewModel.$router</span>) it has a handful of helpful properties and methods.</p>
      <p>They are as follows:</p>
      <ul>
        <li><span class="inline-code">router.setState()</span> - Set the state/url for this router, triggering any routes/controllers.</li>
        <li><span class="inline-code">router.addRoutes()</span> - Add route(s) programmatically.</li>
        <li><span class="inline-code">router.setRoutes()</span> - (clear out and) Set the routes for a router programmatically.</li>
        <li><span class="inline-code">router.currentRoute()</span> - Get the current route details.</li>
        <li><span class="inline-code">router.outlets{}</span> - List/Collection of registered outlets.</li>
      </ul>

      <h3><em class="func-def">router.setState<span>( <span class="param">'/new/state'</span> )</span></em></h3>
      <h3>Set the state/url for this router, triggering any routes/controllers:</h3>
<pre><code class="javascript">// trigger the route that matches for '/about'
router.setState('/about');
</code></pre>

      <h3><em class="func-def">router.addRoutes<span>( <span class="param">[ /* routes */ ]</span> )</span></em></h3>
      <h3>Add route(s) programmatically:</h3>
<pre><code class="javascript">var MainViewModel = fw.viewModel({
  // ...
  router: {},
  // ...
});
var main = new MainViewModel();

main.$router.addRoutes([
  {
    title: 'Index Page',
    route: '/',
    controller: function() { /* ... */ }
  },
  {
    title: 'Book Page',
    route: '/book/:isbn',
    controller: function(params) { /* ... */ }
  }
]);
</code></pre>

      <h3><em class="func-def">router.setRoutes<span>( <span class="param">[ /* routes */ ]</span> )</span></em></h3>
      <h3>(clear out and) Set the routes for a router programmatically:</h3>
<pre><code class="javascript">var MainViewModel = fw.viewModel({
  // ...
  router: {
    routes: [
      {
        title: 'Index Page',
        route: '/',
        controller: function() { /* ... */ }
      },
      {
        title: 'Book Page',
        route: '/book/:isbn',
        controller: function(params) { /* ... */ }
      }
    ]
  },
  // ...
});
var main = new MainViewModel();

main.$router.setRoutes([
  {
    title: 'Different Index Page',
    route: '/',
    controller: function() { /* ... */ }
  },
  {
    title: 'Different Book Page',
    route: '/book/:isbn',
    controller: function(params) { /* ... */ }
  }
]);
</code></pre>

      <h3><em class="func-def">router.currentRoute<span>()</span></em></h3>
      <h3>Get the current route details:</h3>
<pre><code class="javascript">// Browser currently pointed to 'http://application.com/book/22'
var MainViewModel = fw.viewModel({
  namespace: 'Main',
  // ...
  router: {
    routes: [
      {
        title: 'Index Page',
        route: '/',
        controller: function() { /* ... */ }
      },
      {
        title: 'Book Page',
        route: '/book/:isbn',
        controller: function(params) { /* ... */ }
      }
    ]
  },
  // ...
});

// ...

var currentRoute = router.currentRoute();
// currentRoute.segment === '/book/22' (this specific route segment/path)
// currentRoute.url === '/book/22' (full url, includes parent and children segments)
// currentRoute.namedParams.isbn === '22'
// currentRoute.title === 'Book Page'
</code></pre>

      <h3><span class="inline-code">router.outlets{}</span> - List/Collection of registered outlets.</h3>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Main"&gt;
      &lt;!-- ... --&gt;
      &lt;outlet name="main-view"&gt;&lt;/outlet&gt;
      &lt;!-- ... --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="javascript">var Main = fw.viewModel({
  namespace: 'Main',
  router: { /* ... */ }
  initialize: function() { /* ... */ },
  afterBinding: function() {
    // Prints: Registered outlets { 'main-view': function }
    console.log('Registered outlets', this.$router.outlets);
  }
});
</code></pre>
      <div class="note"><span class="label">NOTE:</span> If/When you call the <span class="inline-code">router.$outlet()</span> method that will also register whatever named outlet you refer to (if it is not already registered).</div>

    </div>
  </section>

  <a id="outlets" class="section-anchor"></a>
  <section name="outlets">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Outlets</h1>
    </header>
    <div class="content">
      <p>Outlets are simply areas in your application where you can control what is displayed. Their placement in your application is designated by one or more <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span>
      declarations in your HTML. The <span class="inline-code">name=""</span> key is used by the router to target that specific outlet.</p>

<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Main"&gt;
      &lt;!-- ... --&gt;
      &lt;outlet name="main-view"&gt;&lt;/outlet&gt;
      &lt;!-- ... --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>When you tell an outlet what to show, you are telling it to load a component. Thus for each 'page' or view you want
      to display for an <span class="inline-code">outlet</span>, footwork will need one of the three following things:</p>

      <ul>
        <li>A corresponding view registered (cached/preloaded) via <span class="inline-code">fw.outlets.registerView()</span> or <a href="/api/components#loading-registering" data-bind="$route"><span class="inline-code">fw.components.register()</span></a></li>
        <li>A registered location where it can load the view via <span class="inline-code">fw.outlets.registerViewLocation()</span> or <a href="/api/components#loading-registering" data-bind="$route"><span class="inline-code">fw.components.registerLocation()</span></a></li>
        <li>A component/view available at the default component location (<span class="inline-code">fw.components.defaultLocation()</span>, see <a href="/api/components#loading-registering" data-bind="$route">component registration</a>).</li>
      </ul>
      <div class="note">
        <p><span class="label">NOTE:</span> You can tell an <span class="inline-code">&lt;outlet&gt;&lt;/outlet&gt;</span> to show <em>any</em> component, not just ones you register with <span class="inline-code">fw.outlets.registerView()</span> or 
        <span class="inline-code">fw.outlets.registerViewLocation()</span>. Those methods are simply provided as a shortcut for creating a component and marking it as 'template-only'.</p>
        <p>Also remember that components can contain any depth and complexity of nested viewModels, components, routers, etc. This means you can even nest entire applications within the view of another, all with simple declarative syntax.</p>
      </div>
      <ul>
        <li><a data-bind="$route" href="#outlet-registering" data-bind="$route">Lazy Loading / Registering Views (components without a viewModel)</a></li>
        <li><a data-bind="$route" href="#outlet-usage" data-bind="$route">Usage</a></li>
      </ul>
    </div>
  </section>

  <a id="outlet-registering" class="section-anchor"></a>
  <section name="outlet-registering">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Lazy Loading / Registering Views (components without a viewModel)</h2>
    </header>
    <div class="content">
      <p>Because most things you might want to show in an outlet (pages/views) consist of only template code (they have no corresponding viewModel), footwork provides two shortcut methods for registering a
      template-only outlet view (ie: a page/view/template you can show in an <span class="inline-code">&lt;outlet&gt;&lt;/outlet&gt;</span>).</p>
      <ul>
        <li><span class="inline-code">fw.outlets.registerView()</span> - Cache a view/template for later use (available instantly, no download time).</li>
        <li><span class="inline-code">fw.outlets.registerViewLocation()</span> - Tell footwork where it can download it via AMD/RequireJS (dynamically/lazy loaded for you when requested). Since outlet views are just viewModel-less components, they are resolved just like any other <a href="/api/components#loading-registering" data-bind="$route">AMD/RequireJS loaded component</a>.</li>
      </ul>
      <p>Essentially they are ways to easily create/register a view you can use in an outlet.</p>

      <h3><em class="func-def">fw.outlets.registerView<span>( <span class="param">'viewName'</span>, <span class="param">'&lt;!-- template HTML --&gt;'</span> )</span></em></h3>
      <h3>Register/cache a view for later use:</h3>
<pre><code class="javascript">// Register the 'index-page' template view
fw.outlets.registerView('index-page', '&lt;p&gt;Welcome to footwork.js&lt;/p&gt;');

// Register a different view that has a nested component
fw.outlets.registerView('calendar-page', 'Calendar: &lt;calendar&gt;&lt;/calendar&gt;');
</code></pre>
      <div class="note">
        <p><span class="label">NOTE:</span> It is generally recommended you load your templates via a module system such as RequireJS (don't just write them inline in a string as shown, that was only used as an example for reasons of brevity).</p>
        <p>For an example of how to do this check the <a href="/tutorials" data-bind="$route">tutorials page</a>, or alternatively just specify the location of the view via <span class="inline-code">fw.outlets.registerViewLocation()</span>.</p>
      </div>

      <h3><em class="func-def">fw.outlets.registerViewLocation<span>( <span class="param">'viewName'</span>, <span class="param">'/path/to/template'</span> )</span></em></h3>
      <h3><em class="func-def">fw.outlets.registerViewLocation<span>( <span class="param">[ 'viewName', 'viewName2', ... ]</span>, <span class="param">'/path/to/template/'</span> )</span></em></h3>
      <h3>Tell footwork where it can download a view via AMD/RequireJS:</h3>
<pre><code class="javascript">// Register location of the 'index-page' template view
fw.outlets.registerViewLocation('index-page', '/pages/index-page.html');

/**
 * Footwork will append the filename if you end it with a trailing slash (/)
 * The following will try to load '/otherPages/calendar-page.html' when needed
 */
fw.outlets.registerViewLocation('calendar-page', '/otherPages/');

// Register location for multiple views (the same filename appending occurs):
fw.outlets.registerViewLocation(['calendar-page', 'about-page'], '/otherPages/');
</code></pre>
    </div>
  </section>

  <a id="outlet-usage" class="section-anchor"></a>
  <section name="outlet-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Usage</h2>
    </header>
    <div class="content">
      <p>Once footwork knows how to resolve your outlet view it can be used in your application. From that point you need only place whatever
      <span class="inline-code">&lt;outlet name=""&gt;&lt;/outlet&gt;</span> declarations you want in the HTML and then change/set them via the <span class="inline-code">router.$outlet()</span> method.</p>

      <h3><em class="func-def">router.$outlet<span>( <span class="param">'outletName'</span>, <span class="param">'viewName'</span>, <span class="param">options</span> )</span></em></h3>
      <h3><em class="func-def">router.$outlet<span>( <span class="param">'outletName'</span>, <span class="param">'viewName'</span>, <span class="param">onComplete(containingElement)</span> )</span></em></h3>
      <h3>Trigger an outlet to display a component, optionally providing an onComplete() callback and/or parameters to its viewModel.</h3>
      <h3>Example <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> with a router and outlet:</h3>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Main"&gt;
      &lt;!-- ... --&gt;
      &lt;outlet name="main-view"&gt;&lt;/outlet&gt;
      &lt;!-- ... --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="javascript">var Main = fw.viewModel({
  namespace: 'Main',
  router: { /* ... */ }
  initialize: function() {
    // tell the 'main-view' outlet to show the 'index-page' view/component
    this.$router.$outlet('main-view', 'index-page');
  }
});

fw.viewModels.register('Main', Main);
fw.outlets.registerView('index-page', '&lt;p&gt;This is the index-page view.!&lt;/p&gt;');

fw.start();
</code></pre>
        <div class="note"><span class="label">NOTE:</span> You should be loading your viewModel and template modules externally, do not write them inline as shown! That was done purely to make the example short and more readable.</div>

      <h3>Normally you would perform <span class="inline-code">router.$outlet()</span> calls from inside a route controller, as shown below:</h3>
<pre><code class="javascript">var Main = fw.viewModel({
  namespace: 'Main',
  router: {
    routes: [
      {
        route: '/',
        controller: function() {
          // route changed to '/', make the 'main-view' outlet show the 'index-page' view
          this.$outlet('main-view', 'index-page');
        }
      }, {
        route: '/about',
        controller: function() {
          // route changed to '/about', make the 'main-view' outlet show the 'about-page' view
          this.$outlet('main-view', 'about-page');
        }
      }
    ]
  }
  initialize: function() { /* ... */ }
});
</code></pre>

      <h3>You can provide an <span class="inline-code">onComplete()</span> callback to the <span class="inline-code">router.$outlet()</span> method which is run after the outlet has finished changing its view:</h3>
<pre><code class="javascript">// ...
{
  route: '/about',
  controller: function() {
    this.$outlet('main-view', 'about-page', function(element) {
      console.log('About page is loaded inside of', element);
    });
  }
}
// ...
</code></pre>

      <p>You can also pass an <span class="inline-code">options</span> object to the <span class="inline-code">router.$outlet()</span> method. This object can contain the following:</p>
      <ul>
        <li><span class="inline-code">params:</span> - (<em>optional</em>) Object passed to the <span class="inline-code">initialize()</span> method of the viewModel (if your view/component has a viewModel).</li>
        <li><span class="inline-code">onComplete:</span> - (<em>optional</em>) A callback function which is run after the new view/component is loaded (same as above).</li>
      </ul>
<pre><code class="javascript">// ...
{
  route: '/about',
  controller: function() {
    this.$outlet('main-view', 'about-page', {
      // params object passed to the viewModel initialize() method
      params: { thisObject: 'isPassedToTheComponent' },

      // callback which is run after it is loaded
      onComplete: function(element) {
        console.log('About page is loaded inside of', element);
      }
    });
  }
}
// ...
</code></pre>
      <div class="note"><span class="label">NOTE:</span> Remember that in addition to passing arguments directly from a route, you can also leverage the
      powerful <a href="/api/namespacing" data-bind="$route">namespacing</a> or <a href="/api/broadcastable-receivable" data-bind="$route">broadcastable/receivable</a>
      features of footwork to facilitate communication/initialization of your view component.</div>
    </div>
  </section>

  <a id="route-binding" class="section-anchor"></a>
  <section name="route-binding">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Route Binding</h1>
    </header>
    <div class="content">
      <p>In order to make your links and other elements work with the router, footwork needs to know about them. This is done with the <span class="inline-code">$route</span> binding.</p>
      <p>The <span class="inline-code">$route</span> binding is simply a <a href="http://knockoutjs.com/documentation/custom-bindings.html" target="_blank">custom knockout binding</a> which is created by footwork. This
      binding allows footwork to correctly connect your DOM element event (click, by default) to a router action.</p>
      <p>Whenever footwork encounters the <span class="inline-code">$route</span> binding it will traverse up the DOM node path searching for the nearest parent router. Whenever the designated event occurs on that
      element it will trigger the state change as described on that router.</p>
      <h3><span class="inline-code">$route</span> binding basic example:</h3>
<pre><code class="html">&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Main"&gt;
      &lt;div class="navigation"&gt;
        &lt;!-- 'click' events on these will route application to their href="" paths --&gt;
        &lt;a href="/" data-bind="$route"&gt;Home Page&lt;/a&gt;
        &lt;a href="/about" data-bind="$route"&gt;About Page&lt;/a&gt;
      &lt;/div&gt;

      &lt;outlet name="main-view"&gt;&lt;/outlet&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <div class="note"><span class="label">NOTE:</span> If you do not wish to use the <span class="inline-code">$route</span> binding to trigger state changes you can always just use the <span class="inline-code">router.setState()</span> method.</div>

      <p>The <span class="inline-code">$route</span> binding has a few optional parameters.</p>
      <ul>
        <li><span class="inline-code">url:</span> - <span class="inline-code">string</span> The route to send the application to.</li>
        <li><span class="inline-code">on:</span> - <span class="inline-code">string</span> The event to trigger the action on (click, by default).</li>
        <li><span class="inline-code">handler:</span> - <span class="inline-code">function(event, url)</span> Callback handler for the event.</li>
        <li><span class="inline-code">addActiveClass:</span> - <span class="inline-code">boolean</span> Flag indicating whether or not the 'active' class should be added to the element.</li>
        <li><span class="inline-code">activeClass:</span> - <span class="inline-code">string</span> The classname to add to the element when the route is active (default is 'active').</li>
      </ul>

      <h3><span class="inline-code">url:</span> - <span class="inline-code">string</span> The URL/HREF/route to send the application to:</h3>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;!-- If not provided, footwork will attempt to find the url for the action on the href="" attribute. --&gt;
  &lt;a data-bind="$route: { url: '/about' }"&gt;About Page&lt;/a&gt;
&lt;!-- ... --&gt;</code></pre>

      <h3><span class="inline-code">on:</span> - <span class="inline-code">string</span> The event to trigger the action on (click, by default):</h3>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;!-- Trigger the action on a double-click --&gt;
  &lt;a data-bind="$route: { url: '/about', on: 'dblclick' }"&gt;About Page&lt;/a&gt;
&lt;!-- ... --&gt;</code></pre>

      <h3><span class="inline-code">handler:</span> - <span class="inline-code">function(event, url)</span> Callback handler for the event:</h3>
<pre><code class="html">&lt;!-- ... --&gt;
  &lt;!-- Trigger the action with a custom handler --&gt;
  &lt;a data-bind="$route: { url: '/about', handler: clickHandler }"&gt;About Page&lt;/a&gt;
&lt;!-- ... --&gt;</code></pre>
<pre><code class="javascript">// example viewModel showing the handler from above
var MainViewModel = fw.viewModel({
  // ...
  initialize: function() {
    this.clickHandler = function(event, url) {
      console.log('Route Destination:', url);
      return true; // tell footwork to route to the url (false === do not route)
    }
  }
  // ...
});
</code></pre>
    </div>
  </section>

  <a id="misc" class="section-anchor"></a>
  <section name="misc">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Misc / Utility</h2>
    </header>
    <div class="content">
      <p>Miscelaneous useful and utility methods.</p>
      <ul>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-getAll" data-bind="$route">fw.routers.getAll()</a></span> - Return router (that has optionally been registered for the viewModel 'viewModelNamespaceName').</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-baseRoute" data-bind="$route">fw.routers.baseRoute()</a></span> - Get or set the beginning portion of a route to ignore for the given path.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-activeRouteClassName" data-bind="$route">fw.routers.activeRouteClassName()</a></span> - Get or set the class which is added to an active <span class="inline-code">$route</span> bound element.</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-disableHistory" data-bind="$route">fw.routers.disableHistory()</a></span> - Enable or disable history (or get the current setting).</li>
        <li><span class="inline-code"><a data-bind="$route" href="#routers-html5History" data-bind="$route">fw.routers.html5History()</a></span> - Enable or disable HTML5 history/routing (enable or disable hash-based routes when rendering HREFs for $route bound elements).</li>
      </ul>
    </div>
  </section>

  <a id="routers-getAll" class="section-anchor"></a>
  <section name="routers-getAll">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.getAll<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.getAll<span>( <span class="param">'viewModelNamespaceName'</span> )</span></em></h3>
      <h3>Return router (that has optionally been registered for the viewModel 'viewModelNamespaceName'):</h3>
<pre><code class="javascript">// Explicit registration
var MainViewModel = fw.viewModel({
  namespace: 'MainViewModel'
  router: { /* ... */ }
});
var Widget = fw.viewModel({
  namespace: 'Widget'
  router: { /* ... */ }
});

var main = new MainViewModel();
var widget = new Widget();

var routers = fw.routers.getAll();
// routers === { MainViewModel: router, Widget: router }

var routers = fw.routers.getAll('Widget');
// routers === { Widget: router }</code></pre>
    </div>
  </section>

  <a id="routers-baseRoute" class="section-anchor"></a>
  <section name="routers-baseRoute">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.baseRoute<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.baseRoute<span>( <span class="param">'/path/to/ignore'</span> )</span></em></h3>
      <h3>Get or set the beginning portion of a route to ignore for the given path:</h3>
<pre><code class="javascript">// fw.routers.baseRoute() === ''
fw.routers.baseRoute('/home/directory'); // routers will ignore '/home/directory' at beginning of url</code></pre>
    </div>
  </section>

  <a id="routers-activeRouteClassName" class="section-anchor"></a>
  <section name="routers-activeRouteClassName">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.activeRouteClassName<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.activeRouteClassName<span>( <span class="param">'className'</span> )</span></em></h3>
      <h3>Get or set the class which is added to an active <span class="inline-code">$route</span> bound element:</h3>
<pre><code class="javascript">// fw.routers.activeRouteClassName() === 'active' // default === 'active'
// active routes will now have 'currentlyActive' added to their className
fw.routers.activeRouteClassName('currentlyActive');</code></pre>
    </div>
  </section>

  <a id="routers-disableHistory" class="section-anchor"></a>
  <section name="routers-disableHistory">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.disableHistory<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.disableHistory<span>( <span class="param">isDisabled</span> )</span></em></h3>
      <h3>Enable or disable history (or get the current setting):</h3>
<pre><code class="javascript">// fw.routers.disableHistory() === false (default)
fw.routers.disableHistory(true); // history now disabled, but app still navigable</code></pre>
    </div>
  </section>

  <a id="routers-html5History" class="section-anchor"></a>
  <section name="routers-html5History">
    <div class="highlight"></div>
    <div class="content">
      <h3 class="top"><em class="func-def">fw.routers.html5History<span>()</span></em></h3>
      <h3 class="top"><em class="func-def">fw.routers.html5History<span>( <span class="param">isEnabled</span> )</span></em></h3>
      <h3>Enable or disable HTML5 routes (or get the current setting):</h3>
<pre><code class="javascript">// fw.routers.html5History() === false (default)
fw.routers.html5History(true); // non-hash based URLs will be generated for $route bound A tags</code></pre>
      <div class="note"><span class="label">NOTE:</span> If you want HTML5 based routes generated this must be set to true before your application starts/begins binding.</div>
    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "Routing",
  "description": "Initializing and managing application state.",
  "sections": [
    { "anchor": "introduction",
      "title": "Introduction" },
    { "anchor": "usage",
      "title": "Usage" },
    { "anchor": "configuration",
      "title": "Configuration",
      "subSections": [
        { "anchor": "routes",
          "title": "Routes List" },
        { "anchor": "route",
          "title": "Route Definition" },
        { "anchor": "router-properties",
          "title": "Router Properties" }
      ] },
    { "anchor": "outlets",
      "title": "Outlets",
      "subSections": [
        { "anchor": "outlet-registering",
          "title": "Lazy Loading / Registering Views" },
        { "anchor": "outlet-usage",
          "title": "Usage" }
      ] },
    { "anchor": "route-binding",
      "title": "Route Binding" },
    { "anchor": "misc",
      "title": "Misc / Utility",
      "collapsable": true,
      "isCollapsed": true,
      "subSections": [
        { "anchor": "routers-getAll",
          "title": "fw.routers.getAll()" },
        { "anchor": "routers-baseRoute",
          "title": "fw.routers.baseRoute()" },
        { "anchor": "routers-activeRouteClassName",
          "title": "fw.routers.activeRouteClassName()" },
        { "anchor": "routers-disableHistory",
          "title": "fw.routers.disableHistory()" },
        { "anchor": "routers-html5History",
          "title": "fw.routers.html5History()" }
      ] }
  ]
}
</div>