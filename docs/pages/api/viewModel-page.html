<article>

  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">viewModel</h1>
    </header>
    <div class="content">
      <p>A viewModel can be thought of simply as a container object which your template/HTML/DOM binds to. There are a number of ways to create 
      them, but a simple plain old javascript object (POJO) at its most basic level is all that is needed.</p>
      <p>Footwork viewModel's are unique in that they help with many other aspects/concerns a developer might have such as 
      <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" title="Command Query Responsibility Segregation">CQRS</a>, lifecycle events, routing, component integration, and more.</p>
      <ul>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#initialization">Initialization</a></li>
      </ul>
    </div>
  </section>

  <a id="configuration" class="section-anchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>viewModel constructor functions are created by calling <span class="inline-code">fw.viewModel()</span> and passing it a configuration object.</p>
      <p>The result (a constructor function) can then be used to instantiate new instances of that viewModel.
      These constructor functions are essentially specialized wrappers which enable footwork to hook into both knockout and your viewModel/module to provide for all of the additional features the framework provides.</p>

      <h3>Configuration object synopsis:</h3>
<pre><code data-language="javascript">fw.viewModel({
  /**
   * The namespace (communications channel) the viewModel uses. This is essentially used as
   * the 'key' for CQRS separation between modules. If no namespace is provided a unique one
   * will be automatically assigned.
   *
   * NOTE: This is also prepended to the routers namespace (if a router configuration is supplied)
   *       See: /api/routing
   */
  namespace: 'Sprocket',

  // If true, the namespace will have an auto-incremented 0-based index number appended for each new viewModel
  autoIncrement: false, // default === false

  // Initialization function called at creation of a new viewModel, is passed in parameters supplied at call
  initialize: function(param1, param2, ...) {
    // this === the viewModel object
    // Perform normal viewModel initialization here, just like typical knockout.js code.
    this.param1 = fw.observable(param1);
  },

  // Behavioral mixins to include with each new viewModel created
  mixins: [
    // See: 'Mixins' section on this page
  ],

  // Router configuration object
  router: {
    // See: /api/routing in documentation
  },

  // Function called just after binding to the DOM
  afterBinding: function(containingElement) {
    // this === the viewModel object
  },

  // Function called just before the html this viewModel is bound to is removed from the DOM
  onDispose: function(containingElement) {
    // this === the viewModel object
  }
});</code></pre>
    </div>
  </section>

  <a id="initialization" class="section-anchor"></a>
  <section name="initialization">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Initialization</h2>
    </header>
    <div class="content">
      <p>A viewModel can be created/initialized in 3 different ways:</p>
      <ul>
        <li>Manually initialized (standard knockout methodology).</li>
        <li>Automatically via a <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declaration in the DOM.</li>
        <li>Automatically via a <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM.</li>
      </ul>

<h3>Manual initialization (similar to what would be found in regular knockout.js code):</h3>
<pre><code data-language="javascript">/**
 * You use footwork viewModel class functions just like you would a normal knockout.js constructor function.
 * ie: var viewModelObject = new ConstructorFunc(paramaters ...);
 *
 * Note: The parameters you pass into the ConstructorFunc(params) call get passed
 *       into the initialize(params) function from the configuration object.
 */

// example:
var Sprocket = fw.viewModel({
  // ... configuration object ...
  namespace: 'Sprocket',
  initialize: function(params) {
    // params === object passed in when calling new Sprocket( ... )
    this.type = fw.observable(params.type);
    this.color = params.color || 'orange';
    this.price = fw.observable(params.price);
    this.isExpensive = fw.computed(function() {
      return this.price() > 10;
    }, this);
  }
});

var awesomeSprocket = new Sprocket({ type: 'awesome', price: 3.50 });
// awesomeSprocket.type() === 'awesome'
// awesomeSprocket.color === 'orange'
// awesomeSprocket.isExpensive() === false
</code></pre>

      <h3>Automatic initialization via <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declaration in the DOM:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Sprocket"&gt;
      Type: &lt;span data-bind="text: type"&gt;&lt;/span&gt;
      &lt;!-- ko if: isExpensive --&gt;
        &lt;span class="warning"&gt;This is expensive!&lt;/span&gt;
      &lt;!-- /ko --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> See <a href="#autoloading">autoloading</a> for information on how to make sure footwork knows where to find your viewModels/modules.</p>

      <h3>Automatic initialization via <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;sprocket&gt;&lt;/sprocket&gt;
    &lt;-- NOTE: Both the viewModel and template are either autoloaded via requireJS/AMD, or 
              loaded from cache/configuration you supply to the framework --&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> See <a data-bind="$route" href="/api/components#autoloading">component autoloading</a> for information on how to make sure footwork knows where to find your viewModels/modules and templates based on the component name.</p>
    </div>
  </section>

  <a id="amd-loading" class="section-anchor"></a>
  <section name="amd-loading">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">AMD / Lazy Loading</h2>
    </header>
    <div class="content">
      <p>footwork.js supports (and encourages) the use of requireJS/AMD based loading for a number of reasons:</p>
      <ul>
        <li>It strongly encourages modularization and separation of concerns.</li>
        <li>Helps decouple your application and allow for easier testability.</li>
        <li>footwork can take advantage of its dependency resolution to automatically load necessary resources for you as needed at runtime.</li>
        <li>Allows for easier debugging as non-compiled assets.</li>
        <li>Allows for easy and highly configurable caching/preloading of assets (this includes all components, viewModels, and templates). None, some, or all of it...you choose what your users wait for.</li>
      </ul>
    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "viewModel",
  "description": "viewModel declaration, instantiation, and binding.",
  "sections": [
    { "anchor": "introduction",
      "title": "viewModel",
      "subSections": [
        { "anchor": "configuration",
          "title": "Configuration" },
        { "anchor": "initialization",
          "title": "Initialization" },
        { "anchor": "amd-loading",
          "title": "AMD / Lazy Loading" }
      ] }
  ]
}
</div>