<article>

  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">viewModel</h1>
    </header>
    <div class="content">
      <p>A viewModel can be thought of simply as a container object which your template/HTML/DOM binds to. There are a number of ways to create 
      them, but a simple plain old javascript object (POJO) at its most basic level is all that is needed.</p>
      <p>Footwork viewModel's are unique in that they help with many other aspects/concerns a developer might have such as 
      <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" title="Command Query Responsibility Segregation">CQRS</a>, lifecycle events, routing, component integration, and more.</p>
      <ul>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#initialization">Initialization</a></li>
      </ul>
    </div>
  </section>

  <a id="configuration" class="section-anchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>viewModel constructor functions are created by calling <span class="inline-code">fw.viewModel()</span> and passing it a configuration object.</p>
      <p>The result (a constructor function) can then be used to instantiate new instances of that viewModel.
      These constructor functions are essentially specialized wrappers which enable footwork to hook into both knockout and your viewModel/module to provide for all of the additional features the framework provides.</p>

      <h3>Configuration object synopsis:</h3>
<pre><code data-language="javascript">fw.viewModel({
  /**
   * The namespace (communications channel) the viewModel uses. This is essentially used as
   * the 'key' for CQRS separation between modules. If no namespace is provided a unique one
   * will be automatically assigned.
   *
   * NOTE: This is also prepended to the routers namespace (if a router configuration is supplied)
   *       See: /api/routing
   */
  namespace: 'Sprocket',

  // If true, the namespace will have an auto-incremented 0-based index number appended for each new viewModel
  autoIncrement: false, // default === false

  // Initialization function called at creation of a new viewModel, is passed in parameters supplied at call
  initialize: function(param1, param2, ...) {
    // this === the viewModel object
    // Perform normal viewModel initialization here, just like typical knockout.js code.
    this.param1 = fw.observable(param1);
  },

  // Behavioral mixins to include with each new viewModel created
  mixins: [
    // See: 'Mixins' section on this page
  ],

  // Router configuration object
  router: {
    // See: /api/routing in documentation
  },

  // Function called just after binding to the DOM
  afterBinding: function(containingElement) {
    // this === the viewModel object
  },

  // Function called just before the html this viewModel is bound to is removed from the DOM
  onDispose: function(containingElement) {
    // this === the viewModel object
  }
});</code></pre>
    </div>
  </section>

  <a id="initialization" class="section-anchor"></a>
  <section name="initialization">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Initialization</h2>
    </header>
    <div class="content">
      <p>A viewModel can be created/initialized in 3 different ways:</p>
      <ul>
        <li>Manually initialized (standard knockout methodology).</li>
        <li>Automatically via a <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declaration in the DOM.</li>
        <li>Automatically via a <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM.</li>
      </ul>

      <h3>Manual initialization (similar to what would be found in regular knockout.js code):</h3>
<pre><code data-language="javascript">/**
 * You use footwork viewModel class functions just like you would a normal knockout.js constructor function.
 * ie: var viewModelObject = new ConstructorFunc(paramaters ...);
 *
 * Note: The parameters you pass into the ConstructorFunc(params) call get passed
 *       into the initialize(params) function from the configuration object.
 */

// example:
var Sprocket = fw.viewModel({
  // ... configuration object ...
  namespace: 'Sprocket',
  initialize: function(params) {
    // params === object passed in when calling new Sprocket( ... )
    this.type = fw.observable(params.type);
    this.color = params.color || 'orange';
    this.price = fw.observable(params.price);
    this.isExpensive = fw.computed(function() {
      return this.price() > 10;
    }, this);
  }
});

var awesomeSprocket = new Sprocket({ type: 'awesome', price: 3.50 });
// awesomeSprocket.type() === 'awesome'
// awesomeSprocket.color === 'orange'
// awesomeSprocket.isExpensive() === false
</code></pre>

      <h3>Automatic initialization via <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declaration in the DOM:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Sprocket"&gt;
      Type: &lt;span data-bind="text: type"&gt;&lt;/span&gt;
      &lt;!-- ko if: isExpensive --&gt;
        &lt;span class="warning"&gt;This is expensive!&lt;/span&gt;
      &lt;!-- /ko --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> See <a href="#loading-registering">AMD / Lazy Loading / Registering</a> for information on how to make sure footwork knows how to find your viewModels/modules.</p>

      <h3>Automatic initialization via <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;sprocket&gt;&lt;/sprocket&gt;
    &lt;-- NOTE: Both the viewModel and template are either autoloaded via requireJS/AMD, or 
              loaded from cache/configuration you supply to the framework --&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> See <a data-bind="$route" href="/api/components#loading-registering">component AMD / Lazy Loading / Registering</a> for information on how to tell footwork where to find your component/viewModel/template assets.</p>
    </div>
  </section>

  <a id="loading-registering" class="section-anchor"></a>
  <section name="loading-registering">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">AMD / Lazy Loading / Registering</h2>
    </header>
    <div class="content">
      <p>footwork.js supports both pre-caching/registering your viewModels ahead of time, or optionally automatically loading them via AMD/RequireJS. In either case, the declarative <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> syntax will trigger the loading (if necessary) and binding of the viewModel/module.</p>
      <p>AMD/RequireJS is fully supported (and highly encouraged) for a number of reasons:</p>
      <ul>
        <li>It strongly encourages modularization and separation of concerns.</li>
        <li>Helps decouple your application and allow for easier testability.</li>
        <li>footwork can take advantage of its dependency resolution to automatically load and use resources for you as needed at runtime (<em>including the automatic loading and composing of entire views/pages/routes, components, or viewModels</em>).</li>
        <li>Allows for easier debugging as non-compiled assets while still being buildable for release into a production environment.</li>
        <li>Allows for easy and highly configurable caching/preloading of assets (this includes all components, viewModels, and templates). None, some, or all of it...you choose what your users wait for.</li>
      </ul>

      <p>Automatically loading and wrapping a section of your DOM with a viewModel begins with inserting/wrapping the html in your template with a <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> element.</p>
      <h3>Example:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="[moduleName]"&gt;
      &lt;!-- HTML to be bound using an instance of the viewModel/module --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

      <p>There are 3 ways footwork will try to resolve your viewModel when it encounters the declarative <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> element you place in the DOM.</p>
      <p>Here they are in order of priority:</p>
      <ul>
        <li>Pre-cached via <span class="inline-code">fw.viewModels.register()</span> call.</li>
        <li>Automatic download/resolution via AMD/RequireJS at a pre-registered location (<span class="inline-code">fw.viewModels.registerLocation()</span>).</li>
        <li>Automatic download/resolution via AMD/RequireJS at the configurable default (<span class="inline-code">fw.viewModels.defaultLocation()</span>).</li>
      </ul>

      <h3><em>fw.viewModels.register('moduleName', viewModel)</em></h3>
      <h3>Cache a viewModel/module ahead of time:</h3>
<pre><code data-language="javascript">// register a footwork viewModel
var Sprocket = fw.viewModel({ /* configuration object */ });
fw.viewModels.register('Sprocket', Sprocket);

// register a normal class function (like in regular knockout)
var Sprocket = function() { this.isUsed = fw.observable(false); };
fw.viewModels.register('Sprocket', Sprocket);

// register an instance of an object (like in regular knockout)
fw.viewModels.register('Sprocket', {
  instance: { isUsed: false } // object representing the viewModel to be bound against the DOM
});

/**
 * A constructor function to be called when the declaration is encountered.
 * It is supplied params given at the binding (&lt;viewModel params="exampleParam: true"&gt;) and
 * the containing element of the viewModel.
 */
fw.viewModels.register('Sprocket', {
  createViewModel: function(params, info) {
    // info.element = containing &lt;viewModel&gt; element
    // params are the parameters declaratively created from the DOM (See: note below)
    return { isUsed: false }; // object representing the viewModel to be bound against the DOM
  }
});</code></pre>

      <h3><em>fw.viewModels.registerLocation('moduleName', 'path/to/module')</em></h3>
      <h3>Register the location of a viewModel/module so footwork can load and bind it for you when needed:</h3>
<pre><code data-language="javascript">// Load Sprocket from: /viewModels/parts/Sprocket.js (based on viewModel/module name, case sensitive)
fw.viewModels.registerLocation('Sprocket', '/viewModels/parts');

// Load Sprocket from: /viewModels/parts/DifferentFileName.js (specify full file name)
fw.viewModels.registerLocation('Sprocket', '/viewModels/parts/DifferentFileName.js');

// register the location of several viewModels at once (ie: all in the same folder)
fw.viewModels.registerLocation(['Body', 'Navigation', 'Footer'], '/viewModels/pageAreas'); // NOTE: This is a folder, not an individual file name.</code></pre>

    </div>
  </section>

</article>

<div id="metaData">
{
  "title": "viewModel",
  "description": "viewModel declaration, instantiation, and binding.",
  "sections": [
    { "anchor": "introduction",
      "title": "viewModel",
      "subSections": [
        { "anchor": "configuration",
          "title": "Configuration" },
        { "anchor": "initialization",
          "title": "Initialization" },
        { "anchor": "loading-registering",
          "title": "AMD / Lazy Loading / Registering" }
      ] }
  ]
}
</div>