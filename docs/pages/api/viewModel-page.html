<article>

  <a id="introduction" class="section-anchor"></a>
  <section name="introduction">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">viewModel</h1>
    </header>
    <div class="content">
      <p>A viewModel can be thought of simply as a container object which your template/HTML/DOM binds to. There are a number of ways to create 
      them, but a simple plain old javascript object (POJO) at its most basic level is all that is needed.</p>
      <p>Footwork viewModel's are unique in that they help with many other aspects/concerns a developer might have such as 
      <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" title="Command Query Responsibility Segregation">CQRS</a>, lifecycle events, routing, component integration, and more.</p>
      <ul>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#initialization">Initialization</a></li>
        <li><a href="#loading-registering">AMD / Lazy Loading / Registering</a></li>
      </ul>
    </div>
  </section>

  <a id="configuration" class="section-anchor"></a>
  <section name="configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>viewModel constructor functions are created by calling <span class="inline-code">fw.viewModel()</span> and passing it a configuration object.</p>
      <p>The result (a constructor function) can then be used to instantiate new instances of that viewModel.
      These constructor functions are essentially specialized wrappers which enable footwork to hook into both knockout and your viewModel/module to provide for all of the additional features the framework provides.</p>

      <h3>viewModel configuration object synopsis:</h3>
<pre><code data-language="javascript">fw.viewModel({
  /**
   * The namespace (communications channel) the viewModel uses. This is essentially used as
   * the 'key' for CQRS separation between modules. If no namespace is provided a unique one
   * will be automatically assigned.
   *
   * NOTE: This is also prepended to the routers namespace (if a router configuration is supplied)
   *       See: /api/routing
   */
  namespace: 'Sprocket',

  // If true, the namespace will have an auto-incremented 0-based index number appended for each new viewModel
  autoIncrement: false, // default === false

  // Initialization function called at creation of a new viewModel, it is passed in the parameters supplied at creation
  initialize: function(param1, param2, ...) {
    // this === the viewModel object
    // Perform normal viewModel initialization here, just like typical knockout.js code.
    this.param1 = fw.observable(param1);
  },

  // Behavioral mixins to include with each new viewModel created
  mixins: [
    // See: 'Mixins' section on this page
  ],

  // Router configuration object
  router: {
    // See: /api/routing in documentation
  },

  // Function called just after binding to the DOM
  afterBinding: function(containingElement) {
    // this === the viewModel object
  },

  // Function called just before the html this viewModel is bound to is removed from the DOM
  onDispose: function(containingElement) {
    // this === the viewModel object
  }
});</code></pre>
    </div>
  </section>

  <a id="initialization" class="section-anchor"></a>
  <section name="initialization">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Initialization</h2>
    </header>
    <div class="content">
      <p>A viewModel can be created/initialized in 3 different ways:</p>
      <ul>
        <li>Manually initialized (standard knockout methodology).</li>
        <li>Automatically via a <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declaration in the DOM.</li>
        <li>Automatically via a <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM.</li>
      </ul>

      <h3>Manual initialization (similar to what would be found in regular knockout.js code):</h3>
<pre><code data-language="javascript">/**
 * You use footwork viewModel class functions just like you would a normal knockout.js constructor function.
 * ie: var viewModelObject = new ConstructorFunc(paramaters ...);
 *
 * Note: The parameters you pass into the ConstructorFunc(params) call get passed
 *       into the initialize(params) function from the configuration object.
 */

// example:
var Sprocket = fw.viewModel({
  // ... configuration object ...
  namespace: 'Sprocket',
  initialize: function(params) {
    // params === object passed in when calling new Sprocket( ... )
    this.type = fw.observable(params.type);
    this.color = params.color || 'orange';
    this.price = fw.observable(params.price);
    this.isExpensive = fw.computed(function() {
      return this.price() > 10;
    }, this);
  }
});

var awesomeSprocket = new Sprocket({ type: 'awesome', price: 3.50 });
// awesomeSprocket.type() === 'awesome'
// awesomeSprocket.color === 'orange'
// awesomeSprocket.isExpensive() === false

// You can then bind it to the DOM just like any other knockout viewModel/javascript object:
fw.applyBindings(awesomeSprocket, document.getElementById('sprocket-container'));
</code></pre>

      <h3>Automatic initialization via <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> declaration in the DOM:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="Sprocket"&gt;
      Type: &lt;span data-bind="text: type"&gt;&lt;/span&gt;
      &lt;!-- ko if: isExpensive --&gt;
        &lt;span class="warning"&gt;This is expensive!&lt;/span&gt;
      &lt;!-- /ko --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> See <a href="#loading-registering">AMD / Lazy Loading / Registering</a> for information on how to make sure footwork knows how to find your viewModels/modules.</p>

      <h3>Automatic initialization via <span class="inline-code">&lt;[component-name]&gt;&lt;/[component-name]&gt;</span> declaration in the DOM:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;sprocket&gt;&lt;/sprocket&gt;
    &lt;-- NOTE: Both the viewModel and template are either autoloaded via requireJS/AMD, or 
              loaded from cache/configuration you supply to the framework --&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> See <a data-bind="$route" href="/api/components#loading-registering">component AMD / Lazy Loading / Registering</a> for information on how to tell footwork where to find your component assets.</p>
    </div>
  </section>

  <a id="loading-registering" class="section-anchor"></a>
  <section name="loading-registering">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">AMD / Lazy Loading / Registering</h2>
    </header>
    <div class="content">
      <p>footwork.js supports both pre-caching/registering your viewModels ahead of time or automatically loading via AMD/RequireJS. In either case, the declarative <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> syntax will trigger the loading (if necessary) and binding of the viewModel/module.</p>
      <p>AMD/RequireJS is fully supported (and highly encouraged) for a number of reasons:</p>
      <ul>
        <li>It strongly encourages modularization and separation of concerns.</li>
        <li>Helps decouple your application and allow for easier testability.</li>
        <li>footwork can take advantage of its dependency resolution to automatically load and use resources for you as needed at runtime (<em>including the automatic loading and composing of entire views/pages/routes, components, or viewModels</em>).</li>
        <li>Allows for easier debugging as non-compiled assets while still being buildable for release into a production environment.</li>
        <li>Allows for easy and highly configurable caching/preloading of assets (this includes all components, viewModels, and templates). None, some, or all of it...you choose what your users wait for.</li>
      </ul>

      <p>Automatically loading and wrapping a section of your DOM with a viewModel begins with inserting/wrapping the html in your template with a <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> element.</p>
      <h3>Example:</h3>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;viewModel module="[moduleName]"&gt;
      &lt;!-- HTML to be bound using an instance of the viewModel/module --&gt;
    &lt;/viewModel&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
      <p class="note"><span class="label">NOTE:</span> You can nest viewModels and components within one another.</p>

      <h3>viewModel/module resolution</h3>
      <p>There are 3 ways footwork will try to resolve your viewModel when it encounters the declarative <span class="inline-code">&lt;viewModel module="[moduleName]"&gt; ... &lt;/viewModel&gt;</span> element you place in the DOM.</p>
      <p>Here they are in order of priority:</p>
      <ul>
        <li>Pre-cached via <span class="inline-code">fw.viewModels.register()</span> call.</li>
        <li>Automatic download/resolution via AMD/RequireJS at a pre-registered location (<span class="inline-code">fw.viewModels.registerLocation()</span>).</li>
        <li>Automatic download/resolution via AMD/RequireJS at the configurable default (<span class="inline-code">fw.viewModels.defaultLocation()</span>).</li>
      </ul>

      <h3><em>fw.viewModels.register('moduleName', viewModel)</em></h3>
      <h3>Cache a viewModel/module ahead of time:</h3>
<pre><code data-language="javascript">// register a footwork viewModel
var Sprocket = fw.viewModel({ /* configuration object */ });
fw.viewModels.register('Sprocket', Sprocket);

// register a normal class constructor function (like in regular knockout)
var Sprocket = function() { this.isUsed = fw.observable(false); };
fw.viewModels.register('Sprocket', Sprocket);

// register an instance of an object (like in regular knockout)
fw.viewModels.register('Sprocket', {
  instance: { isUsed: false } // object representing the viewModel to be bound against the DOM
});

/**
 * A constructor function to be called when the declaration is encountered.
 * It is supplied params given at the binding (&lt;viewModel params="exampleParam: true"&gt;) and
 * the containing element of the viewModel.
 */
fw.viewModels.register('Sprocket', {
  createViewModel: function(params, info) {
    // info.element = containing &lt;viewModel&gt; element
    // params are the parameters declaratively created from the DOM (See: note below)
    return { isUsed: false }; // object representing the viewModel to be bound against the DOM
  }
});</code></pre>

      <h3><em>fw.viewModels.registerLocation('moduleName', 'path/to/module')</em></h3>
      <h3>Register the location of a viewModel/module so footwork can load and bind it for you when needed:</h3>
<pre><code data-language="javascript">// Load Sprocket from: /viewModels/parts/Sprocket.js (based on viewModel/module name, case sensitive)
fw.viewModels.registerLocation('Sprocket', '/viewModels/parts');

// Load Sprocket from: /viewModels/parts/DifferentFileName.js (specify full file name)
fw.viewModels.registerLocation('Sprocket', '/viewModels/parts/DifferentFileName.js');

// register the location of several viewModels at once (ie: all in the same folder)
fw.viewModels.registerLocation(['Body', 'Navigation', 'Footer'], '/viewModels/pageAreas');</code></pre>

      <h3><em>fw.viewModels.defaultLocation('path/to/viewModel/folder')</em></h3>
      <h3>Register the default location of viewModels/modules so footwork can load and bind them for you when needed:</h3>
<pre><code data-language="javascript">// Load all viewModels from /myViewModels (based on viewModel/module name, case sensitive)
fw.viewModels.defaultLocation('/myViewModels');

/**
 * This would cause footwork to load '/myViewModels/Sprocket.js' via AMD/RequireJS when it encounters:
 * &lt;viewModel module="Sprocket"&gt; ... &lt;/viewModel&gt;
 */</code></pre>

    </div>
  </section>

  <a id="mixins" class="section-anchor"></a>
  <section name="mixins">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Mixins</h1>
    </header>
    <div class="content">
      <p>Mixins are about reusing behavior, functionality, and code whenever possible. It allows you to write various mixins and then later on combine
      and compose the desired behavior you want for a viewModel at runtime.</p>
      <p>The mixin functionality in footwork is provided via a library called <a href="https://github.com/a2labs/riveter" target="_blank">riveter</a>.
      All <span class="inline-code">fw.viewModel()</span> based constructor functions are riveter constructor functions. Above and beyond the
      functionality outlined here, each object has various methods extended from riveter which can enable you to extend the viewModels in
      various ways, I would encourage you to also <a href="https://github.com/a2labs/riveter" target="_blank">look at its documentation</a>.</p>

      <h3>Basic usage:</h3>
<pre><code data-language="javascript">var bigSprocket = { /* mixin configuration object */ };
var bikeSprocket = { /* mixin configuration object */ };

var Sprocket = fw.viewModel({
  namespace: 'Sprocket',
  initialize: function(param) {
    this.type = param.type;
  },
  mixins: [ bigSprocket, bikeSprocket ]
});

var mySprocket = new Sprocket({ type: 'awesome' });</code></pre>
    </div>
  </section>

  <a id="mixin-configuration" class="section-anchor"></a>
  <section name="mixin-configuration">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Configuration</h2>
    </header>
    <div class="content">
      <p>Each mixin is simply a configuration object defining what the behavior of that mixin is. The behavior you define will be added to each viewModel instance
      it is configured with. The following is a synopsis of the available options with standard mixins included with footwork.</p>
      <h3>Mixin configuration object synopsis:</h3>
<pre><code data-language="javascript">var bigSprocket = {
  _preInit: function(param1, param2, ...) {
    /**
     * called prior to the initialize() method from the viewModel configuration being called
     * params === params passed in at creation
     * this === the viewModel
     */
  },

  mixin: {
    /**
     * these properties are added to 'this' object immediately upon creation, before
     * any methods (including _preInit) are called
     */
    function1: function() {
      // function that is extended onto the viewModel object (this) upon creation, this === the viewModel
    },
    function2: function() {
      // another function that is extended onto the viewModel object (this) upon creation, this === the viewModel
    },
    property1: 'someValue' // a raw property extended to the object
    // ...
  },

  _postInit: function() {
    /**
     * called after the initialize() method from the viewModel configuration is called
     * this === the viewModel
     */
  }
};</code></pre>
      <div class="note">
        <span class="label">NOTE:</span>
        <ul>
          <li>If you require some other type of object extension or mixin, as recommended above you should look at the <a href="https://github.com/a2labs/riveter" target="_blank">riveter documentation</a>.</li>
          <li>A viewModel can have as many mixins as you want, and you can re-use them across as many differing viewModels/modules as you like.</li>
        </ul>
      </div>

      <h3>Example usage:</h3>
<pre><code data-language="javascript">// define the mixin configuration object
var bigSprocket = {
  _preInit: function(param) {
    this.isAwesome = (param.type === 'awesome' ? true : false);
  },
  mixin: {
    isBig: true,
    fitInSmallPlace: function() {
      return false;
    }
  }
};

// create a BigSprocket contructor and include the bigSprocket mixin
var BigSprocket = fw.viewModel({
  namespace: 'Sprocket',
  initialize: function(param) {
    this.type = param.type;
  },
  mixins: [ bigSprocket ]
});

var mySprocket = new BigSprocket({ type: 'awesome' });
// mySprocket.fitInSmallPlace() === false
// mySprocket.isBig === true
// mySprocket.isAwesome === true</code></pre>
    </div>
  </section>


  <a id="mixins" class="section-anchor"></a>
  <section name="mixins">
    <div class="highlight"></div>
    <header>
      <h1 class="sub title">Mixins</h1>
    </header>
    <div class="content">
      <p>footwork.js provides for several ways of extending a viewModels functionality without having to duplicate code. One such powerful way is
      through mixins.</p>
      <p>The mixin functionality in footwork is provided via a library called <a href="https://github.com/a2labs/riveter" target="_blank">riveter</a>.
      All <span class="inline-code">fw.viewModel()</span> based constructor functions are riveter constructor functions. Above and beyond the
      functionality outlined here, each object has various methods extended from riveter which can enable you to extend the viewModels in
      various ways, I would encourage you to also <a href="https://github.com/a2labs/riveter" target="_blank">look at its documentation</a>.</p>

      <h3>Mixin basic usage:</h3>
<pre><code data-language="javascript">var bigSprocket = { /* mixin configuration object */ };
var bikeSprocket = { /* mixin configuration object */ };

var Sprocket = fw.viewModel({
  namespace: 'Sprocket',
  initialize: function(param) {
    this.type = param.type;
  },
  mixins: [ bigSprocket, bikeSprocket ]
});

var mySprocket = new Sprocket({ type: 'awesome' });</code></pre>
    </div>
  </section>

  <a id="mixin-usage" class="section-anchor"></a>
  <section name="mixin-usage">
    <div class="highlight"></div>
    <header>
      <h2 class="sub title">Example mixin usage</h2>
    </header>
    <div class="content">
      <p>Each mixin behavior is added to each new instance of the viewModel that is created. This goes for ones instantiated automatically via declarative HTML, or directly/manually in javascript code.</p>
      <p>All mixins may be reused on both a standalone viewModel and viewModels attributed with a component.</p>
      <h3>Example usage:</h3>
<pre><code data-language="javascript">// define the mixin configuration object
var bigSprocket = {
  _preInit: function(param) {
    this.isAwesome = (param.type === 'awesome' ? true : false);
    // this.isBig === true
  },
  mixin: {
    isBig: true,
    fitInSmallPlace: function() {
      return false;
    }
  }
};

// create a BigSprocket contructor and include the bigSprocket mixin
var BigSprocket = fw.viewModel({
  namespace: 'Sprocket',
  initialize: function(param) {
    this.type = param.type;
  },
  mixins: [ bigSprocket ]
});

var mySprocket = new BigSprocket({ type: 'awesome' });
// mySprocket.fitInSmallPlace() === false
// mySprocket.isBig === true
// mySprocket.isAwesome === true</code></pre>
    </div>
  </section>
</article>

<div id="metaData">
{
  "title": "viewModel",
  "description": "viewModel declaration, instantiation, and binding.",
  "sections": [
    { "anchor": "introduction",
      "title": "viewModel",
      "subSections": [
        { "anchor": "configuration",
          "title": "Configuration" },
        { "anchor": "initialization",
          "title": "Initialization" },
        { "anchor": "loading-registering",
          "title": "AMD / Lazy Loading / Registering" }
      ] },
    { "anchor": "mixins",
      "title": "Mixins",
      "subSections": [
        { "anchor": "mixin-configuration",
          "title": "Configuration" },
        { "anchor": "mixin-usage",
          "title": "Usage" }
      ] }
  ]
}
</div>